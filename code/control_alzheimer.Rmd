---
output: html_document
editor_options: 
  chunk_output_type: console
---
## Control experiment using Alzheimerâ€™s disease risk

Alzheimer SNPs
```{r}
## PMID: 37198259 Multi-ancestry meta-analysis and fine-mapping in Alzheimer's disease
data <- readxl::read_excel("~/41380_2023_2089_MOESM2_ESM.xlsx", sheet = "S5") %>%
  dplyr::select(Chromosome, Position, SNP) %>%
  dplyr::rename("CHR_ID"="Chromosome", "CHR_POS"="Position", "SNP_ID_CURRENT"="SNP") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID)) %>%
  distinct()
```


Get SNPs in LD
```{r}
library(LDlinkR)

snps <- data$SNP_ID_CURRENT
counter <- 1
## Creating list to store res from for loop below. LDproxy does not like multi queries
ldproxy_res <- list()

## For loop to find snps in proxy to the lead snp
for(snp in snps) {
  message("Working on snp",counter, ": ", snp)
  
  res <- LDproxy(
    snp = snp,
    pop = c("CEU", "TSI", "GBR", "IBS"), ## All european pop
    r2d = "r2",
    token = "9dfb615d7a15", ## Unique token. Need to register on ldlink to get your own token
    file = FALSE,
    genome_build = "grch38",
    api_root = "https://ldlink.nih.gov/LDlinkRest"
  )
  res$snp <- snp
  ## Update counter: counter is for knowing where it is.
  counter <- counter + 1
  ldproxy_res[[snp]] <- res
}

## Identify snps that did not have any snp in ld with it
rm.res <- data.frame(ncol = sapply(ldproxy_res, ncol)) %>% dplyr::filter(ncol == 2) %>% rownames()
ldproxy_res <- ldproxy_res[!names(ldproxy_res) %in% rm.res]

ldproxy_res <- as.data.frame(do.call(rbind, ldproxy_res)) %>% remove_rownames()
save(ldproxy_res, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/alz_snpLDproxy.rda")
```

Get nearby genes based on lead SNPs and in LD
```{r}
## Load Alz SNP
load("/drive-pool/data/peter_data/genetic_programming/code/brca/alz_snpLDproxy.rda")
## Filter ld proxy for snps with an R2 of 0.9 and MAF of 0.05 or greater
ld <- ldproxy_res %>% dplyr::filter(R2 >= 0.6,
                                    Dprime >= 0.9) %>%
  dplyr::select(RS_Number, Coord, snp, Alleles, Distance)
rm(ldproxy_res); gc()
## There are cases where the RS_number and snp (lead snp) are the same. Dont know why, but remove those cases.
ld <- ld[-which(ld$RS_Number == ld$snp),] 
## Some snps dont have rsid, just coord. Lets add corrd to rsid for those cases
ld[which(ld$RS_Number == "."), "RS_Number"] <- ld[which(ld$RS_Number == "."), "Coord"]

ld <- ld %>% separate(Coord, c("CHR_ID", "CHR_POS"), sep = ":") %>%
  mutate(CHR_ID = gsub(pattern = ".*chr", replacement = "", x = CHR_ID)) %>%
  dplyr::rename("SNPS"="RS_Number", "LEAD_SNP"="snp")

## Simply df to only include relevant column. Also, add column to say what SNPs have LD 
snps.df <- data %>% dplyr::select(CHR_ID, CHR_POS, SNP_ID_CURRENT) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS", "SNP_id"="SNP_ID_CURRENT") %>% ## Rename columns
  left_join(x = ., ## What lead SNPs have snps in ld
            y = data.frame(SNP_id = unique(ld$LEAD_SNP),
                           LD = 1),
            by = "SNP_id") %>%
  mutate(LD = replace_na(LD, replace = 0))

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.
ldsnps.range <- ld %>% dplyr::group_by(LEAD_SNP) %>%
  dplyr::summarise(min = min(CHR_POS),
                   max = max(CHR_POS))

gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- 10 ## Set the min ngenes a lead snp should have. only needed when elmer.style is false

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)
save(nearbygenes_10xgenomics, file = "/drive-pool/data/peter_data/genetic_programming/alz_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
```

Generate obj function for Alzheimer

```{r}
load("/drive-pool/data/peter_data/genetic_programming/alz_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics); gc()

#######################################################
## Need to update some obj function for the alz snps ##

## First one is ATAC data
## Make gwas snps into granges
## Get all snps (lead snp +  ld)
all.snps <- data[,c("CHR_ID", "CHR_POS", "SNP_ID_CURRENT")] %>%
  dplyr::rename("SNPS"="SNP_ID_CURRENT") %>%
  mutate(CHR_ID = gsub(pattern = "chr\\.*", replacement = "", x = .$CHR_ID)) %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

load("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/PeakCalls/markerList.rda")

celltype <- names(markerList@listData)
atac.marker <- list()

for(n in celltype) {
  marker.df <- as.data.frame(markerList@listData[[n]])
  if(nrow(marker.df) <= 1) { ## If there are no markers for celltype then skip
    next
  } else {
    p <- unlist(strsplit(x = n, split = " "))[1] ## Get only celltype name. Don't care about CF at the end
    ## Get atac-seq probes and make into granges
    marker.granges <- GRanges(seqnames = Rle(marker.df$seqnames),
                              range = IRanges(start = marker.df$start,
                                              end = marker.df$end),
                              idx = marker.df$idx)
    marker.granges <- unique(marker.granges)
    ## Find overlaps between snp and atac region
    hits <- findOverlaps(query = gwas, subject = marker.granges)
    ## Extract results
    # marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
    #   dplyr::select(locus) %>% distinct() %>%
    #   mutate(celltype = p)
    marker.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                        as.data.frame(marker.granges) %>% .[hits@to,]) %>%
      .[,6:13] %>% remove_rownames() %>%
      mutate(celltype = p)
    atac.marker[[p]] <- marker.hit
  }
}
atac.marker <- as.data.frame(do.call(rbind, atac.marker)) %>% remove_rownames() %>%
  mutate(atac = 1) %>% 
  dplyr::select(locus, celltype, atac) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
atac.marker[which(is.na(atac.marker$LEAD_SNP)), "LEAD_SNP"] <- atac.marker[which(is.na(atac.marker$LEAD_SNP)), "locus"]

save(atac.marker, file = "/drive-pool/data/peter_data/genetic_programming/alz_ld_atac.marker.rda")   
load("/drive-pool/data/peter_data/genetic_programming/alz_ld_atac.marker.rda")
#######################
## Common atac peaks ##

#######################################
## Finding Common Peaks in ATAC data ##
loadArchRProject("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/")
projCis <- readRDS(file = "/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/Save-ArchR-Project.rds")

## Checking to see available matrix in data
# getAvailableMatrices(projCis)

## Getting peaks by cell type
peakset <- getPeakSet(projCis)
names(peakset) <- NULL

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

hits <- findOverlaps(query = gwas, subject = peakset)
## Extract results
# marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
#   dplyr::select(locus) %>% distinct() %>%
#   mutate(celltype = p)
common.atac.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                    as.data.frame(peakset) %>% .[hits@to,]) %>% 
  remove_rownames() %>%
  dplyr::select(locus, GroupReplicate, peakType, nearestGene, distToGeneStart, distToTSS) %>% 
  mutate(GroupReplicate = gsub(pattern = "\\s.*", replacement = "", x = GroupReplicate),
         common.atac = 1) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "LEAD_SNP"] <- common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "locus"] 

save(common.atac.hit, file = "/drive-pool/data/peter_data/genetic_programming/alz_ld_atac_peak.rda")
load("/drive-pool/data/peter_data/genetic_programming/alz_ld_atac_peak.rda")

##############
## Promoter ##

## Get atac-seq probes and make into granges
genes.granges <- GRanges(seqnames = Rle(nearbygenes$seqnames),
                       range = IRanges(start = nearbygenes$tss),
                       gene = nearbygenes$gene_name)
genes.granges <- unique(genes.granges)

promoter.granges <- promoters(genes.granges, upstream = 1000, downstream = 100)

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))
## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = promoter.granges)

promoter.df <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(promoter.granges) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  mutate(promoter = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
promoter.df[which(is.na(promoter.df$LEAD_SNP)), "LEAD_SNP"] <- promoter.df[which(is.na(promoter.df$LEAD_SNP)), "locus"]
save(promoter.df, file = "/drive-pool/data/peter_data/genetic_programming/alz_ld_promoter.df.rda")
```

Genetic Algorithm
```{r}
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
load("/drive-pool/data/peter_data/genetic_programming/alz_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
## Load alz data
data <- readxl::read_excel("~/41380_2023_2089_MOESM2_ESM.xlsx", sheet = "S5") %>%
  dplyr::select(Chromosome, Position, SNP) %>%
  dplyr::rename("CHR_ID"="Chromosome", "CHR_POS"="Position", "SNP_ID_CURRENT"="SNP") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID)) %>%
  distinct()

#load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda") ## marker genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda"); rm(marker.list); gc()
load("/drive-pool/data/peter_data/genetic_programming/alz_ld_promoter.df.rda")
promoter.df <- promoter.df %>% mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cevm.rda")
load("/drive-pool/data/peter_data/genetic_programming/alz_ld_atac.marker.rda")
atac.marker <- atac.marker %>% dplyr::rename("marker.atac"="atac") %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
## Merge fusion.gene with breast.cancer.gene
fusion.gene <- fusion.gene %>% dplyr::rename("cancer.gene"="fusion") ## Rename colname for rbind
breast.cancer.gene <- rbind(breast.cancer.gene, fusion.gene) ## rbind together
breast.cancer.gene <- distinct(breast.cancer.gene); rm(fusion.gene) ## Keep unique observation
#load("/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
load("/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
celltalkdb$inter.ppi <- 1 ## Add 
load("/drive-pool/data/peter_data/genetic_programming/alz_ld_atac_peak.rda")
common.atac.hit <- common.atac.hit %>% dplyr::select(locus, GroupReplicate, LEAD_SNP) %>%
  dplyr::rename("celltype"="GroupReplicate") %>%
  mutate(common.atac = 1) %>%
  distinct() %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()


loci2gene <- nearbygenes %>% dplyr::select(snp, gene_name) %>% 
  remove_rownames() %>%
  dplyr::rename("cytoband"="snp") %>%
  distinct()

loci <- unique(loci2gene$cytoband) 

###########################################
## Gene Ontology Cellular Component Prep ##
go_gene <- map.go.gene %>% dplyr::filter(external_gene_name %in% loci2gene$gene_name)
## There is 1844 unique genes in loci2gene, but only 741 mapped with map.go.gene. Why? Naming issue? Lets check
# check.gene <- checkGeneSymbols(unique(map.go.gene$external_gene_name)) %>%
#   dplyr::filter(x != "")
# updated.gene <- check.gene %>% dplyr::filter(Approved == FALSE)
## It's just not mapped to it. Tried updating the gene symbol but no additional matches
#table(go_gene$external_gene_name %in% unique(geneAnnot.df$gene_name))
## Check the original gtf file and all genes from go_gene is present.
## Just the snp doesn't hit those genes. Moving forward.

#############################################
## Highly Mutated/Cancer Driver Genes Prep ##
# breast.cancer.gene

# table(breast.cancer.gene$gene %in% unique(loci2gene$gene_name)) ## Only 20 genes map to loci2gene why?
## Checking to see if gene has updated symbol
# check.gene <- checkGeneSymbols(unique(breast.cancer.gene$gene))
# table(check.gene$Approved == FALSE) ## 185 have the most uptodate gene symbol...
## Lets check loci2gene
# check.gene <- checkGeneSymbols(unique(loci2gene$gene_name)) %>% dplyr::filter(Approved == FALSE) 
## Nope. Most genes with FALSE for approved are noncoding rna. and the very few with updates, they aren't found in breast.cancer.gene.
## So it's really only 20 genes for highly mutated genes/ cancer genes based on these snps
## Check the original gtf file and 186 of 190 genes from breast cancer gene is present.
## Again, just the snp doesn't hit those genes. Moving forward.

############
## PPI df ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
## Update the link data to have gene symbol
str.db.link <- str.db.link %>% dplyr::select(protein1, protein2, experiments, 
                                             experiments_transferred, combined_score) %>%
  left_join(x = ., y = str.db.info, by = c("protein1"="string_id")) %>%
  dplyr::rename("gene1"="gene_symbol") %>%
  left_join(x = ., y = str.db.info, by = c("protein2"="string_id")) %>%
  dplyr::rename("gene2"="gene_symbol") %>%
  .[,c("protein1", "protein2", "gene1", "gene2", "experiments", "experiments_transferred", "combined_score")]

ppi <- str.db.link %>% dplyr::select(gene1, gene2) %>%
  dplyr::filter(gene1 %in% map.genes$gene_name, 
                gene2 %in% map.genes$gene_name) %>% ## Filter for specific genes found in gwas 200kb
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct(); rm(str.db.info, map.genes, str.db.link); gc()


## Prepare intra.cellular ppi
## Remove gene combo found in celltalkdb
celltalk_gene <- celltalkdb %>% dplyr::select(source_genesymbol, target_genesymbol) %>%
  dplyr::rename("gene1"="source_genesymbol", "gene2"="target_genesymbol") %>%
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_"))
  
intra.ppi.gene <- ppi %>% 
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(!grp %in% celltalk_gene$grp) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()

######################
## Load Magma genes ##
magma <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/UKB_Breast_cancer.gene_score.txt") %>%
  'colnames<-' ("n") %>%
  separate(n, sep = ":", c("gene", "Mscore")) %>% 
  mutate(magma = 1) %>% dplyr::select(-Mscore)

#table(magma$gene %in% unique(nearbygenes$gene_name)) ## 173 magma genes found out of 1k based on 206 snps
#table(magma$gene %in% unique(geneAnnot.df$gene_name)) ## 952 magma genes found out of 1k in original gtf.
## Again, just the snp doesn't hit those genes. Moving forward.

## Combine findmarkers and cevm
combined.gene.marker <- rbind(cevm.genes, marker.hits) %>% distinct()

## Load lncRNA interaction
load("/drive-pool/data/peter_data/genetic_programming/code/brca/rna.protein.map.rda")
rna.protein.map <- rna.protein.map %>% 'colnames<-' (c("gene1", "gene2")) %>%
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()


## Generate 1k proposals
celltype <- as.character(unique(sct_rna$CellType))
n_proposal <- 1e3
multi_proposal <- mclapply(X = as.list(1:n_proposal), FUN = function(x) {
  generate_proposal() %>% mutate(n = x)
  },
  mc.cores = 10)

multi_proposal <- as.data.frame(do.call(rbind, multi_proposal))
#save(multi_proposal, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi_proposal_071323.rda")
## Objective function
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac") #, "cevm", , "multi.ppi", "findmarkers", "cevm", "go.cc.ppi" #, 


gwas_gp <- function(init.proposal, generations, obj.fun, exclude.celltype = c("ERGpos_Tumor", "ERGneg_Tumor"), khan.method) {
  ## Store result for fitness function
  fitness.res.list <- list() 
  ## Store initial proposal as df
  df <- init.proposal
  n.loci <- length(unique(df$locus))
  ## Set initial proposal as top proposal. This df will be updated to only include the top 1k proposals by avg of avg using current and new proposal
  top.df <- init.proposal
  #################################################################
  ## Loop through proposal for each generation using the obj fun ##
  for(generation in 1:generations) {
    message(paste0("Working on F", generation-1))
    
    ## When we're on the last generation, save the result of the proposal so we can output it. 
    if(generation == max(generations)) {
      last.gen <- df ## Record the last generation
      last.gen$gen <- generation -1
    }
    
    ## Storing results from obj fun for fitness function
    obj.fun.res <- list()

    #############################
    ## CEVM Objective Function ##
    if("cevm" %in% obj.fun) { ## If cevm then do the following
      if(is.null(exclude.celltype)) { 
        cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(cevm = 1)
      } else {
        cevm <- cevm.genes %>% mutate(cevm = 1)
      }
      cevm.obj <- df %>% left_join(x = ., y = cevm, by = c("gene", "celltype")) %>%
        mutate(cevm = replace_na(cevm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cevm = sum(cevm) / length(cevm))
      obj.fun.res[["cevm"]] <- as.data.frame(cevm.obj)
    }
    
    ####################################
    ## FindMarkers Objective Function ##
    if("findmarkers" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(fm = 1)
      } else {
        fm <- marker.hits %>% mutate(fm = 1)
      }
      fm.obj <- df %>% left_join(x = ., y = fm, by = c("gene", "celltype")) %>%
        mutate(fm = replace_na(fm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(fm = sum(fm) / length(fm))
      obj.fun.res[["findmarkers"]] <- as.data.frame(fm.obj)
    }
    
    ########################################
    ## Combined gene marker - CEVM and FM ##
    if("marker.gene" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            marker.gene <- combined.gene.marker %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker.gene = 1)
      } else {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
      }
      marker.gene.obj <- df %>% left_join(x = ., y = marker.gene, by = c("gene", "celltype")) %>%
        mutate(marker.gene = replace_na(marker.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(marker.gene = sum(marker.gene) / length(marker.gene))
      obj.fun.res[["marker.gene"]] <- as.data.frame(marker.gene.obj)
    }
    ##############################
    ## Magma Objective Function ##
    if("magma" %in% obj.fun) {
      magma.obj <- df %>% left_join(x = ., y = magma, by = "gene") %>%
        mutate(magma = replace_na(magma, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(magma = sum(magma) / length(magma))
      obj.fun.res[["magma"]] <- as.data.frame(magma.obj)
    }
    
    if("hi.mut" %in% obj.fun) {
      hi.mut.obj <- df %>% left_join(x = ., y = breast.cancer.gene, by = "gene") %>%
        mutate(cancer.gene = replace_na(cancer.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cancer.gene = sum(cancer.gene) / length(cancer.gene))
      obj.fun.res[["hi.mut"]] <- as.data.frame(hi.mut.obj)
    }
    
    ############################
    ## PPI Objective Function ##
    if(any(c("ppi", "intra.ppi", "inter.ppi", "marker.ppi", "go.cc.ppi") %in% obj.fun)) {
      ppi.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- ppi %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x) 
      
      }, mc.cores = 10)
      ppi.obj <- as.data.frame(do.call(rbind, ppi.obj))
      
      if("intra.ppi" %in% obj.fun) {
        intra.df <-  ppi.obj %>% mutate(intra.commun = case_when(celltype1 == celltype2 ~ 1,
                                                        celltype1 != celltype2 ~ 0)) %>%
          ## Label each cases as 1 or 0 for having same celltype or not, then filter for 1.
          dplyr:::filter(intra.commun == 1) %>%
          group_by(grp = paste(pmax(gene1, gene2), ## Keep only intra combo (no celltalk combo)
                               pmin(gene1, gene2), sep = "_")) %>%
          dplyr::filter(!grp %in% celltalk_gene$grp) %>%
          ungroup() %>%
          dplyr::select(-grp) %>%
          distinct()
        intra.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
          intra.ppi.genes <- intra.df %>% dplyr::filter(n == x)
          if(nrow(intra.ppi.genes) > 0) {
            intra.ppi.genes <- data.frame(gene = unique(c(intra.ppi.genes$gene1, intra.ppi.genes$gene2)),
                                          intra.ppi = 1)
            ## Get specific proposal set 
            intra.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = intra.ppi.genes, by = "gene") %>%
              mutate(intra.ppi = replace_na(intra.ppi, replace = 0)) %>%
              summarise(intra.ppi = sum(intra.ppi) /length(intra.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "intra.ppi")]
          } else {
            intra.res <- data.frame(n = x,
                                    intra.ppi = 0)
          }
        }, mc.cores = 10)
        intra.obj <- as.data.frame(do.call(rbind, intra.obj))
        obj.fun.res[["intra.ppi"]] <- intra.obj
      } ## End of intra ppi
      
      if("ppi" %in% obj.fun) {
        all.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          ppi.df <- ppi.obj %>% dplyr::filter(n == x)
          ppi.genes <- data.frame(gene = unique(c(ppi.df$gene1, ppi.df$gene2)),
                                  ppi = 1)
          ppi.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = ppi.genes, by = "gene") %>%
              mutate(ppi = replace_na(ppi, replace = 0)) %>%
              dplyr::summarise(ppi = sum(ppi) / length(ppi)) %>%
              mutate(n = x) %>% .[, c("n", "ppi")]
        }, mc.cores = 10)
        all.ppi.obj <- as.data.frame(do.call(rbind, all.ppi.obj))
        obj.fun.res[["ppi"]] <- all.ppi.obj
      } ## End of ppi
      
      if("marker.ppi" %in% obj.fun) {
        if(is.null(exclude.celltype)) {
          # fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          # cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          } else {
            marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          }
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() #%>% ## Keep positive hits.
        
        if(nrow(marker.obj) == 0) {
          marker.ppi.obj <- data.frame(n = unique(df$n),
                                       marker.ppi = 0)
        } else {
          marker.ppi.obj <- mclapply(X = as.list(unique(marker.obj$n)), FUN = function(x) {
            marker.df <- marker.obj %>% dplyr::filter(n == x)
            df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            marker.ppi.set <- rbind(df1, df2) %>% mutate(marker.ppi = 1) %>% distinct()
          
            marker.res <- df %>% dplyr::filter(n == x) %>%
                left_join(x = ., y = marker.ppi.set, by = c("gene", "celltype")) %>%
                mutate(marker.ppi = replace_na(marker.ppi, replace = 0)) %>%
                dplyr::summarise(marker.ppi = sum(marker.ppi) / length(marker.ppi)) %>%
                mutate(n = x) %>% .[, c("n", "marker.ppi")]
            }, mc.cores = 10)
          marker.ppi.obj <- as.data.frame(do.call(rbind, marker.ppi.obj))
        }
      
        obj.fun.res[["marker.ppi"]] <- marker.ppi.obj
      } ## End of marker.ppi
      
      if("inter.ppi" %in% obj.fun) {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() %>% ## Keep positive hits.
          dplyr::select(-marker.gene.x, -marker.gene.y) ## Get rid of columns no longer needed
        
        if(nrow(marker.obj) == 0) {
          inter.ppi.obj <- data.frame(n = unique(df$n),
                                      inter.ppi = 0)
        } else {
          ## First identity all source genes in celltalkdb. We will check if the source gene is found in 
          ## gene1 or gene2. If no source gene in either then remove. If source gene is found in both 
          ## Then remove. We will be filtering for rowsums == 1 on source_genesymbol1 and 2.
          inter.obj <- marker.obj %>% left_join(x = ., 
                                                y = celltalkdb[,c("source_genesymbol", "inter.ppi")], 
                                                by = c("gene1"="source_genesymbol"),
                                                relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("source_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("source_genesymbol", "inter.ppi")],
                      by = c("gene2"="source_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>% 
            dplyr::rename("source_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("source_gene1", "source_gene2")], na.rm = TRUE) == 1),] %>%
          
            ## Now trying to find targets the same way we did for source genes
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene1"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene2"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("target_gene1", "target_gene2")], na.rm = TRUE) == 1),] %>%
            ## Removing target and source identity column
            dplyr::select(-source_gene1, -source_gene2, -target_gene1, -target_gene2)

          inter.ppi.obj <- mclapply(X = as.list(unique(inter.obj$n)), FUN = function(x) {
            marker.df <- inter.obj %>% dplyr::filter(n == x)
            df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            inter.ppi.set <- rbind(df1, df2) %>% mutate(inter.ppi = 1) %>% distinct()
          
            inter.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = inter.ppi.set, by = c("gene", "celltype")) %>%
              mutate(inter.ppi = replace_na(inter.ppi, replace = 0)) %>%
              dplyr::summarise(inter.ppi = sum(inter.ppi) / length(inter.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "inter.ppi")]
            }, mc.cores = 10)
          inter.ppi.obj <- as.data.frame(do.call(rbind, inter.ppi.obj)) 
          }
        
        obj.fun.res[["inter.ppi"]] <- inter.ppi.obj
      } ## End of inter.ppi
      
      if("multi.ppi" %in% obj.fun) {
        multi.obj <- ppi.obj %>% dplyr::select(-celltype1,-celltype2) %>% distinct()
        multi.res <- mclapply(X = as.list(unique(multi.obj$n)), FUN = function(x) {
          multi.df <- multi.obj %>% dplyr::filter(n %in% x)
          df1 <- multi.df %>% dplyr::select(gene1, locus1) %>% dplyr::rename("gene"="gene1", "locus"="locus1")
          df2 <- multi.df %>% dplyr::select(gene2, locus2) %>% dplyr::rename("gene"="gene2", "locus"="locus2")
          gene.locus.set <- rbind(df1, df2) %>% mutate(set = paste(gene, locus, sep = "_")) %>%  ## Combine df1 and df2 and create set name
            group_by(set) %>% ## Group by set
            tally() %>% ## ## Count up how many times the set appears
            dplyr::filter(n > 1) %>% nrow() ## Select gene locus combination with more than one interaction
         res <- data.frame(n = x, multi.ppi = gene.locus.set / n.loci)
        }, mc.cores = 10)
        multi.res <- as.data.frame(do.call(rbind, multi.res))
         obj.fun.res[["multi.ppi"]] <- multi.res
      } ## End of multi.ppi
      
      if("go.cc.ppi" %in% obj.fun) {
        go.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          go.ppi.df <- ppi.obj %>% dplyr::filter(n == x) %>% dplyr::select(-celltype1, -celltype2) %>%
            left_join(x = ., ## Add cellular component info for all genes in gene1 (NA means no info on gene)
                      y = map.go.gene[,c("external_gene_name", "name_1006")], 
                      by = c("gene1"="external_gene_name"), 
                      relationship = "many-to-many") %>%
            dplyr::rename("cc1"="name_1006") %>% ## Rename cc column as cc1 to link to gene1
            left_join(x = ., ## Add cc info for gene2
                      y = map.go.gene[,c("external_gene_name", "name_1006")],
                      by = c("gene2"="external_gene_name"),
                      relationship = "many-to-many") %>%
            dplyr::rename("cc2"="name_1006") %>% ## Rename cc column as cc2 to link to gene2
            .[which(.$cc1 == .$cc2),] ## Filter for cases where gene1 and gene2 are in same cellular compartment
          ## Get all genes from go.ppi.df
          go.genes <- data.frame(gene = unique(c(go.ppi.df$gene1, go.ppi.df$gene2)),
                                  go.cc = 1)
          go.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = go.genes, by = "gene") %>%
              mutate(go.cc = replace_na(go.cc, replace = 0)) %>%
              dplyr::summarise(go.cc = sum(go.cc) / length(go.cc)) %>%
              mutate(n = x) %>% .[, c("n", "go.cc")]
        }, mc.cores = 10)
        go.ppi.obj <- as.data.frame(do.call(rbind, go.ppi.obj))
        
        obj.fun.res[["go.cc.ppi"]] <- go.ppi.obj
      }
      
    } ## End of broad ppi umbrella

    #################################
    ## Promoter Objective Function ##
    if("promoter" %in% obj.fun) {
      promoter.obj <- df %>% left_join(x = ., y = promoter.df, by = c("locus", "gene")) %>%
        mutate(promoter = replace_na(promoter, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(promoter = sum(promoter)/length(promoter))
      obj.fun.res[["promoter"]] <- promoter.obj
    }
    
    #############################
    ## ATAC Objective Function ##
    ## Marker atac peak 
    if("marker.atac" %in% obj.fun) {
      m.atac.obj <- df %>% left_join(x = ., y = atac.marker, by = c("locus", "celltype")) %>%
        mutate(marker.atac = replace_na(marker.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(marker.atac = sum(marker.atac)/length(marker.atac))
      obj.fun.res[["marker.atac"]] <- m.atac.obj
    }
    ## Common atac peak
    if("common.atac" %in% obj.fun) {
      c.atac.obj <- df %>% left_join(x = ., y = common.atac.hit, by = c("locus", "celltype")) %>%
        mutate(common.atac = replace_na(common.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(common.atac = sum(common.atac)/length(common.atac))
      obj.fun.res[["common.atac"]] <- c.atac.obj
    }
    ########################
    ## lncrna interaction ##
    if("lncrna.ppi" %in% obj.fun) {
      lncrna.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- rna.protein.map %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x)
      }, mc.cores = 10)
      lncrna.obj <- as.data.frame(do.call(rbind, lncrna.obj))
      
      all.lncrna.obj <- mclapply(X = as.list(unique(lncrna.obj$n)), FUN = function(x) {
        lncrna.df <- lncrna.obj %>% dplyr::filter(n == x)
        lncrna.genes <- data.frame(gene = unique(c(lncrna.df$gene1, lncrna.df$gene2)),
                                lncrna = 1)
        lncrna.res <- df %>% dplyr::filter(n == x) %>%
          left_join(x = ., y = lncrna.genes, by = "gene") %>%
          mutate(lncrna = replace_na(lncrna, replace = 0)) %>%
          dplyr::summarise(lncrna = sum(lncrna) / length(lncrna)) %>%
          mutate(n = x) %>% .[, c("n", "lncrna")]
        }, mc.cores = 10)
      all.lncrna.obj <- as.data.frame(do.call(rbind, all.lncrna.obj))
      
      lncrna.res <- data.frame(n = unique(df$n)) %>%
        left_join(x = ., y = all.lncrna.obj, by = "n") %>%
        mutate(lncrna = replace_na(lncrna, replace = 0))
      obj.fun.res[["lncrna.ppi"]] <- lncrna.res
    } ## end of lncrna
    
    
    
    #####################################
    ## Fitness mean objective function ##
    
    for(n in 1:length(obj.fun)) {
      if(n == 1) {
        fitness.obj <- obj.fun.res[[obj.fun[n]]]
      } else {
        add_test <- obj.fun.res[[obj.fun[n]]]
        fitness.obj <- left_join(x = fitness.obj, y = add_test, by = "n")
      }
    }
    fitness.obj[is.na(fitness.obj)] <- 0
    fitness.obj$fitness <- apply(X = fitness.obj %>% dplyr::select(-n), MARGIN = 1, FUN = function(x) {
      mean(x)
    })
    fitness.obj$gen <- generation - 1 
    
    
    ##########
    ## Rank ##
    ## Rank the proposals into 5 groups
    ranked.proposals <- fitness.obj %>% dplyr::select(n, fitness) %>% arrange(., desc(fitness)) %>%
      mutate(quantile = rep(x = 5:1, each = nrow(.)/5))
    ## Prob of quantiles
    group.prob <- c(0.02,0.03,0.05,0.1,0.8)
    names(group.prob) <- 1:max(ranked.proposals$quantile)
    
    #####################
    ## Updating top.df ##

    if(generation-1 == 0) { 
      top.df$gen <- generation - 1
      fitness.df <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
    } else {
      new.fitness <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
      ## Update top rank proposal df with new generation data. Basically, replace proposals that are weaker than the new proposals
      fitness.df <- rbind(fitness.df, new.fitness) %>% arrange(desc(fitness)) %>% .[1:1000,]
      ## Update top df proposal elements based on fitness.df
      keep.list <- fitness.df %>% dplyr::select(n, gen) %>% mutate(keep = 1)
      current.proposal <- df %>% mutate(gen = generation - 1)
      top.df <- rbind(top.df, current.proposal) %>% left_join(x = ., y = keep.list, by = c("n", "gen")) %>%
        dplyr::filter(keep == 1) %>%
        dplyr::select(-keep)
      }
    
    ###################################
    ## Randomly Select 100 Proposals ##
    sel.proposal <- progressive_quantile(group.prob = group.prob, n_proposal = 1e2, proposal = ranked.proposals)
    
    ############
    ## Mating ##
    new.proposal <- mating.pair(sel.proposal = sel.proposal, df = df, khan.method = khan.method, fitness.df = fitness.df, top.df = top.df,
                                generation = generation, n.loci = n.loci)
    new.proposal <- as.data.frame(do.call(rbind,new.proposal)) %>% remove_rownames() %>%
      mutate(n = rep(1:1000, each = n.loci))
    ##############
    ## Mutation ##
    new.proposal <- add.mutations(new.proposal = new.proposal)

    ## Insert khan to the proposal
    rand.kick <- new.proposal %>% rownames_to_column(var = "row") %>% slice_sample(n = 1) %>% .$n
    new.proposal <- new.proposal %>% dplyr::filter(n != rand.kick)

    khan <- fitness.df[1,] ## Which gen and proposal is khan?
    khan.df <- top.df %>% dplyr::filter(n == khan$n, ## Get khan proposals
                                        gen == khan$gen) %>%
      dplyr::select(-gen) %>%
      mutate(n = 1000 + generation)

    new.proposal <- rbind(khan.df, new.proposal)

    ###########################################
    ## Remove one random and add khan inside ##

    df <- new.proposal ## Overwrite multi_proposal with new.proposal

    ###############
    ## Store res ##
    fitness.res.list[[generation]] <- fitness.obj
    

  } ## End loop for generations
  fitness.res.list[["proposal"]] <- last.gen
  fitness.res.list[["top"]] <- top.df
  fitness.res.list[["fitness"]] <-fitness.df
  return(fitness.res.list)
} ## End of wrapper


ga.run <- gwas_gp(init.proposal = multi_proposal, generations = 5, obj.fun = obj.fun, khan.method = TRUE)

test.run <- multi.gp[[3]]
#test.run <- ga.run
top.proposal <- ga.run[["proposal"]]

genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))


date()
multi.gp <- mclapply(X = as.list(1:3), FUN = function(x) {
  gwas_gp(init.proposal = multi_proposal, generations = 100, obj.fun = obj.fun, khan.method = TRUE)
  }, mc.cores = 3)
date()
save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/alz_ld_multi.run_120623.rda")
```



Compare breast vs alz
```{r}
## Load alz data
load("/drive-pool/data/peter_data/genetic_programming/alz.ctrl.multi.gp_092523.rda")
alz_data <- alz.ctrl.multi.gp[[1]]
alz_data <- as.data.frame(do.call(rbind, alz_data[1:100])) %>%
  dplyr::select(n, gen, fitness)

## Avg fitness per gen
alz_fitness <- alz_data %>% dplyr::group_by(gen) %>% dplyr::summarise(avg = mean(fitness)) %>%
  mutate(type = "alzheimer")

## Load breast data
load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_090523.rda")
b_data <- multi.gp[[1]]
b_data <- as.data.frame(do.call(rbind, b_data[1:100])) %>%
  dplyr::select(n, gen, fitness)

## Avg fitness per gen
b_fitness <- b_data %>% dplyr::group_by(gen) %>% dplyr::summarise(avg = mean(fitness)) %>%
  mutate(type = "breast")

fitness.res <- rbind(alz_fitness, b_fitness)

## fitness diff
fitness.diff <- alz_data %>% dplyr::select(gen, fitness) %>% dplyr::rename("alzheimer"="fitness") %>%
  mutate(breast = b_data$fitness)
fitness.diff$diff_bva <- fitness.diff$breast - fitness.diff$alzheimer

p1 <- ggplot(fitness.res, aes(x = gen, y = avg, colour = type)) +
  geom_line() +
  ylab("Average Fitness") + xlab("Generation") + labs(colour = "") +
  ggtitle("Fitness Comparison - Breast vs Alzheimer's using Breast GA") +
  theme_bw() +
  theme(legend.position = c(.92,.35),
        legend.background = element_rect(fill = "transparent", colour = "transparent"))
p2 <- ggplot(fitness.diff, aes(x = gen, y = diff_bva)) +
  geom_point(alpha = 0.25) + 
  xlab("Generation") + ylab("Difference of Fitness") +
  theme_bw() 

library(patchwork)
layout <- "A\nB"
dev.off()
combined.plot <- p1 + p2 + plot_layout(design = layout)
ggsave(filename = "~/breast_alz_fitness_compare.png", width = 12, height = 7)


## Lets look at the density plot for the last generation (gen = 100)
## How much overlap do you see. is it 50% or 2%
b.last.gen <- b_data %>% dplyr::filter(gen == 99) %>% dplyr::select(fitness) %>% mutate(type = "breast")
a.last.gen <- alz_data %>% dplyr::filter(gen == 99) %>% dplyr::select(fitness) %>% mutate(type = "alzheimer")

combined.last.gen <- rbind(a.last.gen, b.last.gen); rm(b.last.gen, a.last.gen); gc()

ggplot(combined.last.gen, aes(x = fitness, color = type)) +
  geom_density() +
  theme_bw()

## Based on the result, the density of alzheimer and breast fitness score do not overlap very little. So the difference is significance but the effect size is small.

## The next thing is to compare the distribution of confidence score between cell type and gene and maybe a combination score. Also, we need to check what genes were nominated in the last generation. Since alzheimer is an inflammation of the brain, we should expect to see cell types confidently called as lymphoid or myeloid.

## Function to get the top gene and cell type called by snp
get.confid.call <- function(data, loci) {
  genes <- subset(data, select = c(locus, gene))
  geneframe <- data.frame(locus=character(length(loci)), 
                          gene = character(length(loci)), Freq = integer(length(loci)))
  j <- 1
  for (i in unique(genes$locus)) {
    genetab <- as.data.frame(table(subset(genes, locus==i)))
    topgene <- which(genetab$Freq == max(genetab$Freq))
    if(length(topgene)>1) {
      topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
      }
    geneframe[j,1] <- as.character(genetab[topgene,1])
    geneframe[j,2] <- as.character(genetab[topgene,2])
    geneframe[j,3] <- genetab[topgene,3]
    j <- j+1
    }
  
  cells <- subset(data, select = c(locus, celltype))
  cellframe <- data.frame(locus=character(length(loci)), 
                          celltype = character(length(loci)), Freq = integer(length(loci)))
  j <- 1
  for (i in unique(cells$locus)) {
    celltab <- as.data.frame(table(subset(cells, locus == i)))
    topcell <- which(celltab$Freq == max(celltab$Freq))
    if(length(topcell)>1) {
      topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
      }
    cellframe[j,1] <- as.character(celltab[topcell,1])
    cellframe[j,2] <- as.character(celltab[topcell,2])
    cellframe[j,3] <- celltab[topcell,3]
    j <- j+1
    }
  result <- merge(geneframe, cellframe, by = "locus") %>%
    left_join(x = ., 
              y = distinct(nearbygenes[, c("gene_name", "gene_type")]), 
              by = c("gene"="gene_name"))
}

##
alz_data <- alz.ctrl.multi.gp[[1]][["proposal"]]
alz.res <- get.confid.call(data = alz_data, loci = length(unique(alz_data$locus)))
alz.res$gene_type <- NULL

b_data <- multi.gp[[2]][["proposal"]]
b.res <- get.confid.call(data = b_data, loci = length(unique(b_data$locus)))
b.res$gene_type <- NULL

alz_hi_confid <- alz.res %>% dplyr::filter(Freq.y >= 750, ## cell type hi confid
                                           Freq.x >= 750) %>% ## gene hi confid
  mutate(type = "alzheimer")
alz_hi_confid$celltype <- gsub(pattern = "\\s.*", replacement = "", x = alz_hi_confid$celltype) ## for some reason there is a CF in some of the cell type. i need to go back later and fix that bug. 09/26/23. Will update later in this comment box.

b_hi_confid <- b.res %>% dplyr::filter(Freq.y >= 750, ## cell type hi confid
                                       Freq.x >= 750) %>% ## gene hi confid
  mutate(type = "breast")

combo_hi_confid <- rbind(alz_hi_confid, b_hi_confid); rm(alz_hi_confid, b_hi_confid)

bp_hc <- as.data.frame(table(combo_hi_confid$celltype, combo_hi_confid$type)) %>%
  dplyr::filter(Freq > 0)

load("/drive-pool/data/peter_data/genetic_programming/kelly.colours.rda")
ggplot(bp_hc, aes(fill=Var1, y=Freq, x=Var2)) + 
  geom_bar(position="stack", stat="identity") +
  scale_fill_manual(values = kelly.colours[c(3:21)]) +
  theme_minimal() +
  theme(aspect.ratio = 2/1)

## Based on the stacked barplot above, Alzheimer is tending to call lymphoid and myeloid cells confidently and breast are calling epithelial tissue confidently. Thats sort of a relief because again, Alzheimer is a inflammatory disease. 

## get confid score for cell type
alz.cc <- alz.res %>% dplyr::select(Freq.y) %>%
  mutate(type = "alzheimer")
b.cc <- b.res %>% dplyr::select(Freq.y) %>%
  mutate(type = "breast")
cc <- rbind(alz.cc, b.cc); rm(alz.cc, b.cc); gc()

p1 <- ggplot(cc, aes(x = Freq.y, color = type)) +
  geom_density() +
  theme_bw() +
  ggtitle("Celltype Confidence Call")

alz.cg <- alz.res %>% dplyr::select(Freq.x) %>%
  mutate(type = "alzheimer")
b.cg <- b.res %>% dplyr::select(Freq.x) %>%
  mutate(type = "breast")
cg <- rbind(alz.cg, b.cg); rm(alz.cg, b.cg); gc()

p2 <- ggplot(cg, aes(x = Freq.x, color = type)) +
  geom_density() +
  theme_bw() +
  ggtitle("Gene Confidence Call")

alz.combined <- data.frame(count = alz.res$Freq.x + alz.res$Freq.y,
                           type = "alzheimer")
b.combined <- data.frame(count = b.res$Freq.x + b.res$Freq.y,
                         type = "breast")
combined.cc.cg <- rbind(alz.combined, b.combined); rm(alz.combined, b.combined); gc()

p3 <- ggplot(combined.cc.cg, aes(x = count, color = type)) +
  geom_density() +
  theme_bw() +
  ggtitle("Combined Confidence Call")

dev.off()
layout <- "A\nB\nC"
combined.plot <- p1 + p2 + p3 + plot_layout(design = layout)
ggsave(filename = "~/breast_alz_confidencecall_compare.png", width = 12, height = 7)
```

Checking to see if SNPs in breast and alzheimer data are in LD with one another
```{r}
## Get snp for alzheimer and breast
alz.locus <- data.frame(snp = alz.res$locus,
                        type = "alzheimer")
b.locus <- data.frame(snp = b.res$locus,
                      type = "breast")

## Checking to see if there are any rsid that match the other dataset
table(alz.locus$snp %in% b.locus$snp) ## Nope, they are unique snps

locus <- rbind(alz.locus, b.locus)
write.table(x = locus$snp, file = "~/for_ldprune.txt",
            quote = FALSE,
            row.names = FALSE)

library(motifbreakR, include.only = "snps.from.rsid")
library(SNPlocs.Hsapiens.dbSNP155.GRCh38)
library(BSgenome.Hsapiens.UCSC.hg38)

locus$snp[grep(pattern = "rs", x = locus$snp)]

snps.mb <- snps.from.rsid(rsid = locus$snp[grep(pattern = "rs", x = locus$snp)],
                          dbSNP = SNPlocs.Hsapiens.dbSNP155.GRCh38,
                          search.genome = BSgenome.Hsapiens.UCSC.hg38)
names(snps.mb) <- NULL

snps.mb <- as.data.frame(snps.mb)
snps.mb <- snps.mb[, c("seqnames", "start", "SNP_id")]
snps.mb <- distinct(snps.mb)

chr.id <- as.character(unique(snps.mb$seqnames))

library(LDlinkR)
snpclip.res <- list()

for(n in chr.id) {
  ## Filter data for specific chrid
  snps <- snps.mb %>% dplyr::filter(seqnames %in% n) %>% pull(SNP_id)
  
  if(length(snps) == 1) { ## If there's only 1 snp then rep the same snp. SNPclip doesn't like 1 entry
    snps <- c(snps, snps) 
  }
  ## Use SNPclip to find SNPS in high LD (r2 >= 0.8)
  snp.res <- SNPclip(snps,
                     pop = c("CEU", "TSI", "GBR", "IBS"),
                     r2_threshold = "0.8",
                     maf_threshold = "0.01",
                     token = "9dfb615d7a15",
                     file = FALSE,
                     genome_build = "grch38",
                     api_root = "https://ldlink.nih.gov/LDlinkRest")
  
  ## Store res for post analysis
  snpclip.res[[n]] <- snp.res
}

snpclip.res <- as.data.frame(do.call(rbind, snpclip.res))
rownames(snpclip.res) <- NULL
snpclip.res[grep(pattern = "MAF is", x = snpclip.res$Details), "Details"] <- "Low MAF. Variant removed."

table(snpclip.res$Details)
```