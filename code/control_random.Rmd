---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
## PMID 33270826
## Using sampling tool to get random background

## Will be sampling based on the following criteria
## Distance from TSS
## Gene density
## Number of LD
```

Calculate Gene Density
```{r}
rm(list = ls(all.names = T)); gc()
## Prep data for finding nearest genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda") ## gene annotation
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda") ## Finemap snp

## Simply df to only include relevant column. Also, add column to say what SNPs have LD
snps.df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS, SNP_ID_CURRENT) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS", "SNP_id"="SNP_ID_CURRENT") %>% ## Rename columns
  mutate(seqnames = paste0("chr", seqnames), ## add chr before chromosome id
         LD = 0) %>% ## LD is 0 because we are not adding LD into the mix atm
  distinct()

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.

gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- NULL ## Setting min genes to NULL. We are interested in the gene density with a 200kb window

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)

rm(list=setdiff(ls(), "nearbygenes_10xgenomics")) ## remove everything except nearbygenes

as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  ggplot(data = ., aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Total ngenes") + ylab("Density") +
  ggtitle(paste0("Number of Genes per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

## Based on the results, the deviation that will be used for vsampler for gene density is 20.
```

Calculate distance from TSS 
```{r}
## Create empty vector 
dist.nearby <- vector(mode = "numeric",
                      length = length(unique(nearbygenes_10xgenomics$snp)))

counter <- 1
for(n in unique(nearbygenes_10xgenomics$snp)) { ## loop through each snp and get closest gene to snp length
  p <- nearbygenes_10xgenomics %>% dplyr::filter(snp == n) %>% 
    pull(distance_tss) %>% abs() %>% ## get distance column and take absolute value
    min()
  dist.nearby[counter] <- p
  
  ## add counter to move to next vector
  counter <- counter + 1
}

dist.nearby <- data.frame(x = dist.nearby)
ggplot(data = dist.nearby, aes(x = x)) +
  geom_density() +
  theme_minimal() +
  xlab("Distance to TSS") + ylab("Density") +
  ggtitle(paste0("Closest Distance to TSS per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

## Based on the results, the deviation that will be used for vsampler for distance from tss is 100k.
```

Calculate number of LD per SNP
```{r}

load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")

n.ld <- as.data.frame(table(ld$LEAD_SNP))

ggplot(data = n.ld, aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Number of SNPs in LD") + ylab("Density") +
  ggtitle(paste0("Number of SNPs in LD per SNP - "))

## Based on the results, the deviation that will be used for vsampler for number of SNPs in LD is 100.
```

Running vsampler with values determined by chunks above
```{r}
## Need to get SNPs id / Chromosome ID and POS for snps for matching
## Will use coordinates because variants don't have RSID.
#rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda"); rm(gwas_catalog) ## Finemap snp

df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS) %>%
  distinct()

write.table(x = df, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vsampler_input_breast.txt",
            row.names = FALSE,
            col.names = FALSE,
            sep = "\t",
            quote = FALSE)

## Ran vsampler using webserver on Dec 11 2023

vs_out <- fread("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vsampler/anno.out.txt")

n_query <- length(which(vs_out$LABEL == "query"))
## Because there is 10 controls for every query, I have to make a column so I can filter for specific query and matched controls
vs_out$GROUP <- rep(1:n_query, each = 11)

vs_controls <- list() 

for(n in 1:3) { ## Get 3 control sets
  vs_controls[[n]] <- vs_out %>%
    dplyr::filter(LABEL != "query") %>%
    dplyr::group_by(GROUP) %>%
    slice_sample(n = 1)
}  

save(vs_controls, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda")

## Compare Gene Density
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  gd.control <- data.frame(type = p,
                         ngene = df$Gene_Dis_KB200)
  if(n == 1) {
    res <- gd.control
  } else {
    res <- rbind(res, gd.control)
  }
}

gd.brca <- as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  'colnames<-' (c("type", "ngene")) %>%
  mutate(type = "brca")

gd.plotdata <- rbind(gd.brca, res)

p1 <- ggplot(data = gd.plotdata, aes(x = ngene, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Gene Density") + ylab("Density") 

## Compare Distance to TSS
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  tss.control <- data.frame(type = p,
                            tss = df$DTCT)
  if(n == 1) {
    res <- tss.control
  } else {
    res <- rbind(res, tss.control)
  }
}

tss.brca <- data.frame(type = "brca",
                      tss = dist.nearby$x)

tss.plotdata <- rbind(tss.brca, res)

p2 <- ggplot(data = tss.plotdata, aes(x = tss, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Distance to TSS") + ylab("Density") 

## Compare Number of LD
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  ld.control <- data.frame(type = p,
                            ld = df$inLDvariants_LD6)
  if(n == 1) {
    res <- ld.control
  } else {
    res <- rbind(res, ld.control)
  }
}

ld.brca <- data.frame(type = "brca",
                      ld = n.ld$Freq)

ld.plotdata <- rbind(ld.brca, res)

p3 <- ggplot(data = ld.plotdata, aes(x = ld, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Number of SNPs in LD") + ylab("Density") 


## Combine plots together
layout <- "ABC" ## plot layout

combined.p <- p1 + p2 + p3 + plot_layout(design = layout, guides = "collect")
dev.off()
ggsave(file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/figure/rand.control.characteristic.png",
       width = 14,
       height = 7)
```

## Prepare random control for GA model
```{r}
rm(list = ls(all.names = T)); gc()
## There are 3 sets of column in here. Just gonna randomly choose 1
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda") 
set.seed(514)
x <- sample(x = 1:3, size = 1)

ctrl <- vs_controls[[x]] ## Select control
rm(vs_controls, x); gc()

data <- ctrl %>% dplyr::select(CHR, POS, LABEL) %>%
  dplyr::rename("CHR_ID"="CHR", "CHR_POS"="POS", "SNP_ID_CURRENT"="LABEL") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID),
         SNP_ID_CURRENT = paste0(SNP_ID_CURRENT, "_", rownames(.))) %>%
  distinct()
```

Get SNPs in LD
```{r}
library(LDlinkR)


## Because there's no rsid. will be using coord
## Setup looks like this chr7:24966446
snps <- paste0(data$CHR_ID,":",data$CHR_POS)
counter <- 1
## Creating list to store res from for loop below. LDproxy does not like multi queries
ldproxy_res <- list()

## For loop to find snps in proxy to the lead snp
for(snp in snps) {
  message("Working on snp",counter, ": ", snp)
  
  res <- LDproxy(
    snp = snp,
    pop = c("CEU", "TSI", "GBR", "IBS"), ## All european pop
    r2d = "r2",
    token = "9dfb615d7a15", ## Unique token. Need to register on ldlink to get your own token
    file = FALSE,
    genome_build = "grch38",
    api_root = "https://ldlink.nih.gov/LDlinkRest"
  )
  res$snp <- snp
  ## Update counter: counter is for knowing where it is.
  counter <- counter + 1
  ldproxy_res[[snp]] <- res
}

## Identify snps that did not have any snp in ld with it
rm.res <- data.frame(ncol = sapply(ldproxy_res, ncol)) %>% dplyr::filter(ncol == 2) %>% rownames() ## Nothing to remove
#ldproxy_res <- ldproxy_res[!names(ldproxy_res) %in% rm.res]

ldproxy_res <- as.data.frame(do.call(rbind, ldproxy_res)) %>% remove_rownames()
save(ldproxy_res, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_snpLDproxy.rda")
```

Get nearby genes based on lead SNPs and in LD
```{r}
## Load ctrl SNP
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_snpLDproxy.rda")
## Filter ld proxy for snps with an R2 of 0.9 and MAF of 0.05 or greater
ld <- ldproxy_res %>% dplyr::filter(R2 >= 0.6,
                                    Dprime >= 0.9) %>%
  dplyr::select(RS_Number, Coord, snp, Alleles, Distance)
rm(ldproxy_res); gc()
## There are cases where the RS_number and snp (lead snp) are the same. Dont know why, but remove those cases.
if(any((ld$RS_Number == ld$snp))) {
  ld <- ld[-which(ld$RS_Number == ld$snp),] 
}

## Some snps dont have rsid, just coord. Lets add corrd to rsid for those cases
ld[which(ld$RS_Number == "."), "RS_Number"] <- ld[which(ld$RS_Number == "."), "Coord"]

ld <- ld %>% separate(Coord, c("CHR_ID", "CHR_POS"), sep = ":") %>%
  mutate(CHR_ID = gsub(pattern = ".*chr", replacement = "", x = CHR_ID)) %>%
  dplyr::rename("SNPS"="RS_Number", "LEAD_SNP"="snp")

## Simply df to only include relevant column. Also, add column to say what SNPs have LD 
snps.df <- data %>% ungroup() %>% dplyr::select(CHR_ID, CHR_POS) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS") %>% ## Rename columns
  mutate(SNP_id = paste0(seqnames,":",start)) %>%
  left_join(x = ., ## What lead SNPs have snps in ld
            y = data.frame(SNP_id = unique(ld$LEAD_SNP),
                           LD = 1),
            by = "SNP_id") %>%
  mutate(LD = replace_na(LD, replace = 0))

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.
ldsnps.range <- ld %>% dplyr::group_by(LEAD_SNP) %>%
  dplyr::summarise(min = min(CHR_POS),
                   max = max(CHR_POS))

load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")
gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- 10 ## Set the min ngenes a lead snp should have. only needed when elmer.style is false

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)
save(nearbygenes_10xgenomics, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
```

Generate obj function for control match
```{r}
load("/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics); gc()

#######################################################
## Need to update some obj function for the alz snps ##

## First one is ATAC data
## Make gwas snps into granges
## Get all snps (lead snp +  ld)
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda") 
set.seed(514)
x <- sample(x = 1:3, size = 1)

ctrl <- vs_controls[[x]] ## Select control
rm(vs_controls, x); gc()

data <- ctrl %>% ungroup() %>% dplyr::select(CHR, POS) %>%
  dplyr::rename("CHR_ID"="CHR", "CHR_POS"="POS") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID),
         SNP_ID_CURRENT = paste0(CHR_ID, ":", CHR_POS)) %>%
  distinct()


all.snps <- data[,c("CHR_ID", "CHR_POS")] %>%
  mutate(SNPS = paste0(CHR_ID, ":", CHR_POS)) %>%
  mutate(CHR_ID = gsub(pattern = "chr\\.*", replacement = "", x = .$CHR_ID)) %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

load("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/PeakCalls/markerList.rda")

celltype <- names(markerList@listData)
atac.marker <- list()

for(n in celltype) {
  marker.df <- as.data.frame(markerList@listData[[n]])
  if(nrow(marker.df) <= 1) { ## If there are no markers for celltype then skip
    next
  } else {
    p <- unlist(strsplit(x = n, split = " "))[1] ## Get only celltype name. Don't care about CF at the end
    ## Get atac-seq probes and make into granges
    marker.granges <- GRanges(seqnames = Rle(marker.df$seqnames),
                              range = IRanges(start = marker.df$start,
                                              end = marker.df$end),
                              idx = marker.df$idx)
    marker.granges <- unique(marker.granges)
    ## Find overlaps between snp and atac region
    hits <- findOverlaps(query = gwas, subject = marker.granges)
    ## Extract results
    # marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
    #   dplyr::select(locus) %>% distinct() %>%
    #   mutate(celltype = p)
    marker.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                        as.data.frame(marker.granges) %>% .[hits@to,]) %>%
      .[,6:13] %>% remove_rownames() %>%
      mutate(celltype = p)
    atac.marker[[p]] <- marker.hit
  }
}
atac.marker <- as.data.frame(do.call(rbind, atac.marker)) %>% remove_rownames() %>%
  mutate(atac = 1) %>% 
  dplyr::select(locus, celltype, atac) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
atac.marker[which(is.na(atac.marker$LEAD_SNP)), "LEAD_SNP"] <- atac.marker[which(is.na(atac.marker$LEAD_SNP)), "locus"]

save(atac.marker, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")   
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")
#######################
## Common atac peaks ##

#######################################
## Finding Common Peaks in ATAC data ##
loadArchRProject("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/")
projCis <- readRDS(file = "/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/Save-ArchR-Project.rds")

## Checking to see available matrix in data
# getAvailableMatrices(projCis)

## Getting peaks by cell type
peakset <- getPeakSet(projCis)
names(peakset) <- NULL

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

hits <- findOverlaps(query = gwas, subject = peakset)
## Extract results
# marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
#   dplyr::select(locus) %>% distinct() %>%
#   mutate(celltype = p)
common.atac.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                    as.data.frame(peakset) %>% .[hits@to,]) %>% 
  remove_rownames() %>%
  dplyr::select(locus, GroupReplicate, peakType, nearestGene, distToGeneStart, distToTSS) %>% 
  mutate(GroupReplicate = gsub(pattern = "\\s.*", replacement = "", x = GroupReplicate),
         common.atac = 1) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "LEAD_SNP"] <- common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "locus"] 

save(common.atac.hit, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")

##############
## Promoter ##

## Get atac-seq probes and make into granges
genes.granges <- GRanges(seqnames = Rle(nearbygenes$seqnames),
                       range = IRanges(start = nearbygenes$tss),
                       gene = nearbygenes$gene_name)
genes.granges <- unique(genes.granges)

promoter.granges <- promoters(genes.granges, upstream = 1000, downstream = 100)

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))
## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = promoter.granges)

promoter.df <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(promoter.granges) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  mutate(promoter = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
promoter.df[which(is.na(promoter.df$LEAD_SNP)), "LEAD_SNP"] <- promoter.df[which(is.na(promoter.df$LEAD_SNP)), "locus"]
save(promoter.df, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_promoter.df.rda")
```

Genetic Algorithm
```{r}
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
## Load ctrl data
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda") 
set.seed(514)
x <- sample(x = 1:3, size = 1)

ctrl <- vs_controls[[x]] ## Select control
rm(vs_controls, x); gc()

data <- ctrl %>% ungroup() %>% dplyr::select(CHR, POS) %>%
  dplyr::rename("CHR_ID"="CHR", "CHR_POS"="POS") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID),
         SNP_ID_CURRENT = paste0(CHR_ID, ":", CHR_POS)) %>%
  distinct()

#load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda") ## marker genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda"); rm(marker.list); gc()
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_promoter.df.rda")
promoter.df <- promoter.df %>% mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cevm.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")
atac.marker <- atac.marker %>% dplyr::rename("marker.atac"="atac") %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
## Merge fusion.gene with breast.cancer.gene
fusion.gene <- fusion.gene %>% dplyr::rename("cancer.gene"="fusion") ## Rename colname for rbind
breast.cancer.gene <- rbind(breast.cancer.gene, fusion.gene) ## rbind together
breast.cancer.gene <- distinct(breast.cancer.gene); rm(fusion.gene) ## Keep unique observation
#load("/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
load("/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
celltalkdb$inter.ppi <- 1 ## Add 
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")
common.atac.hit <- common.atac.hit %>% dplyr::select(locus, GroupReplicate, LEAD_SNP) %>%
  dplyr::rename("celltype"="GroupReplicate") %>%
  mutate(common.atac = 1) %>%
  distinct() %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()


loci2gene <- nearbygenes %>% dplyr::select(snp, gene_name) %>% 
  remove_rownames() %>%
  dplyr::rename("cytoband"="snp") %>%
  distinct()

loci <- unique(loci2gene$cytoband) 

###########################################
## Gene Ontology Cellular Component Prep ##
go_gene <- map.go.gene %>% dplyr::filter(external_gene_name %in% loci2gene$gene_name)
## There is 1844 unique genes in loci2gene, but only 741 mapped with map.go.gene. Why? Naming issue? Lets check
# check.gene <- checkGeneSymbols(unique(map.go.gene$external_gene_name)) %>%
#   dplyr::filter(x != "")
# updated.gene <- check.gene %>% dplyr::filter(Approved == FALSE)
## It's just not mapped to it. Tried updating the gene symbol but no additional matches
#table(go_gene$external_gene_name %in% unique(geneAnnot.df$gene_name))
## Check the original gtf file and all genes from go_gene is present.
## Just the snp doesn't hit those genes. Moving forward.

#############################################
## Highly Mutated/Cancer Driver Genes Prep ##
# breast.cancer.gene

# table(breast.cancer.gene$gene %in% unique(loci2gene$gene_name)) ## Only 20 genes map to loci2gene why?
## Checking to see if gene has updated symbol
# check.gene <- checkGeneSymbols(unique(breast.cancer.gene$gene))
# table(check.gene$Approved == FALSE) ## 185 have the most uptodate gene symbol...
## Lets check loci2gene
# check.gene <- checkGeneSymbols(unique(loci2gene$gene_name)) %>% dplyr::filter(Approved == FALSE) 
## Nope. Most genes with FALSE for approved are noncoding rna. and the very few with updates, they aren't found in breast.cancer.gene.
## So it's really only 20 genes for highly mutated genes/ cancer genes based on these snps
## Check the original gtf file and 186 of 190 genes from breast cancer gene is present.
## Again, just the snp doesn't hit those genes. Moving forward.

############
## PPI df ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
## Update the link data to have gene symbol
str.db.link <- str.db.link %>% dplyr::select(protein1, protein2, experiments, 
                                             experiments_transferred, combined_score) %>%
  left_join(x = ., y = str.db.info, by = c("protein1"="string_id")) %>%
  dplyr::rename("gene1"="gene_symbol") %>%
  left_join(x = ., y = str.db.info, by = c("protein2"="string_id")) %>%
  dplyr::rename("gene2"="gene_symbol") %>%
  .[,c("protein1", "protein2", "gene1", "gene2", "experiments", "experiments_transferred", "combined_score")]

ppi <- str.db.link %>% dplyr::select(gene1, gene2) %>%
  dplyr::filter(gene1 %in% map.genes$gene_name, 
                gene2 %in% map.genes$gene_name) %>% ## Filter for specific genes found in gwas 200kb
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct(); rm(str.db.info, map.genes, str.db.link); gc()


## Prepare intra.cellular ppi
## Remove gene combo found in celltalkdb
celltalk_gene <- celltalkdb %>% dplyr::select(source_genesymbol, target_genesymbol) %>%
  dplyr::rename("gene1"="source_genesymbol", "gene2"="target_genesymbol") %>%
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_"))
  
intra.ppi.gene <- ppi %>% 
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(!grp %in% celltalk_gene$grp) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct()

######################
## Load Magma genes ##
magma <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/UKB_Breast_cancer.gene_score.txt") %>%
  'colnames<-' ("n") %>%
  separate(n, sep = ":", c("gene", "Mscore")) %>% 
  mutate(magma = 1) %>% dplyr::select(-Mscore)

#table(magma$gene %in% unique(nearbygenes$gene_name)) ## 173 magma genes found out of 1k based on 206 snps
#table(magma$gene %in% unique(geneAnnot.df$gene_name)) ## 952 magma genes found out of 1k in original gtf.
## Again, just the snp doesn't hit those genes. Moving forward.

## Combine findmarkers and cevm
combined.gene.marker <- rbind(cevm.genes, marker.hits) %>% distinct()

## Load lncRNA interaction
load("/drive-pool/data/peter_data/genetic_programming/code/brca/rna.protein.map.rda")
rna.protein.map <- rna.protein.map %>% 'colnames<-' (c("gene1", "gene2")) %>%
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct()


## Generate 1k proposals
celltype <- as.character(unique(sct_rna$CellType))
n_proposal <- 1e3
multi_proposal <- mclapply(X = as.list(1:n_proposal), FUN = function(x) {
  generate_proposal() %>% mutate(n = x)
  },
  mc.cores = 10)

multi_proposal <- as.data.frame(do.call(rbind, multi_proposal))
#save(multi_proposal, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi_proposal_071323.rda")
# save(atac.marker, breast.cancer.gene, celltalk_gene, celltalkdb, cevm.genes, combined.gene.marker, common.atac.hit, intra.ppi.gene,
#      magma, marker.hits, ppi, promoter.df, rna.protein.map, 
#      file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/ctrl.gp.prereq.rda")
## Objective function
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac") #, "cevm", , "multi.ppi", "findmarkers", "cevm", "go.cc.ppi" #, 

obj.fun <- c("ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter")

#########################
#########################
## Genetic programming ##
#########################
#########################

date()
multi.gp <- mclapply(X = as.list(1:3), FUN = function(x) {
  gwas_gp(init.proposal = multi_proposal, generations = 100, obj.fun = obj.fun, khan.method = TRUE)
  }, mc.cores = 3)
date()
#save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_ld_multi.run_121323.rda")
save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_multi.run_nobreastmultiomics_013124.rda")

load("/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_ld_multi.run_121323.rda")
test.run <- multi.gp[[2]]
top.proposal <- test.run[["proposal"]]
loci <- 174
genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))

## OF Scores
fitness.allgen <- as.data.frame(do.call(rbind, test.run[1:100]))

gp.plotdata <- fitness.allgen %>% gather(data = ., key = "method", value = "fraction", -n, -gen)
unique(gp.plotdata$method)
gp.plotdata$method <- factor(gp.plotdata$method, levels = c("marker.gene", "magma", "cancer.gene", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna", "promoter", "marker.atac", "common.atac", "fitness")) 

ggplot(data = gp.plotdata, aes(x = gen, y = fraction)) +
  geom_point(alpha = 0.02, position = "jitter", pch = 16) +
  theme_minimal() +
  xlab("Generations") + ylab("Fraction of Hits") +
  facet_wrap(.~method, scale = "free") +
  ggtitle("Genetic Programming: Progressive Sampling Summary - Control") +
  scale_x_continuous(breaks = seq(0, 100, by = 25))
```

Compare results from BRCA, Alzheimer and matched controls
```{r}
rm(list = ls(all.names = T)); gc()

####################
## Load ctrl data ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_ld_multi.run_121323.rda")
ctrl_data <- multi.gp[[2]]; rm(multi.gp)
ctrl_data <- as.data.frame(do.call(rbind, ctrl_data[1:100])) %>%
  dplyr::select(n, gen, fitness)

## Avg fitness per gen
ctrl_fitness <- ctrl_data %>% dplyr::group_by(gen) %>% dplyr::summarise(avg = mean(fitness)) %>%
  mutate(type = "control")

###################
## Load alz data ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/alz_ld_multi.run_120623.rda")
alz_data <- multi.gp[[1]]; rm(multi.gp)
alz_data <- as.data.frame(do.call(rbind, alz_data[1:100])) %>%
  dplyr::select(n, gen, fitness)

## Avg fitness per gen
alz_fitness <- alz_data %>% dplyr::group_by(gen) %>% dplyr::summarise(avg = mean(fitness)) %>%
  mutate(type = "alzheimer")

######################
## Load breast data ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_110723.rda")
b_data <- multi.gp[[1]]; rm(multi.gp)
b_data <- as.data.frame(do.call(rbind, b_data[1:100])) %>%
  dplyr::select(n, gen, fitness)

## Avg fitness per gen
b_fitness <- b_data %>% dplyr::group_by(gen) %>% dplyr::summarise(avg = mean(fitness)) %>%
  mutate(type = "breast")



fitness.res <- rbind(ctrl_fitness, alz_fitness, b_fitness)

## fitness diff
fitness.diff <- alz_data %>% dplyr::select(gen, fitness) %>% dplyr::rename("alzheimer"="fitness") %>%
  mutate(breast = b_data$fitness,
         control = ctrl_data$fitness)
fitness.diff$diff_bva <- fitness.diff$breast - fitness.diff$alzheimer
fitness.diff$diff_bvc <- fitness.diff$breast - fitness.diff$control

## Convert difference into density so we can see where it all stacks.
library(MASS)
library(viridis)
#> Loading required package: viridisLite
theme_set(theme_bw(base_size = 16))

# Get density of points in 2 dimensions.
# @param x A numeric vector.
# @param y A numeric vector.
# @param n Create a square n by n grid to compute density.
# @return The density within each square.
get_density <- function(x, y, ...) {
  dens <- MASS::kde2d(x, y, ...)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}

fitness.diff$bva_density <- get_density(fitness.diff$gen, fitness.diff$diff_bva, n = 100)
fitness.diff$bvc_density <- get_density(fitness.diff$gen, fitness.diff$diff_bvc, n = 100)

## Generate last gen
c_lastgen <- ctrl_data %>% dplyr::filter(gen == 99) %>% mutate(type = "control")
b_lastgen <- b_data %>% dplyr::filter(gen == 99) %>% mutate(type = "breast")
a_lastgen <- alz_data %>% dplyr::filter(gen == 99) %>% mutate(type = "alzheimer")

lastgen <- rbind(c_lastgen, b_lastgen, a_lastgen)

## Plot data
type.color <- c("purple", "pink", "grey")
names(type.color) <- c("alzheimer", "breast", "control")

p1 <- ggplot(fitness.res, aes(x = gen, y = avg, colour = type)) +
  geom_line() +
  ylab("Average Fitness") + xlab("Generation") + labs(colour = "") +
  ggtitle("Fitness Comparison - Breast vs Alzheimer's using Breast GA") +
  scale_color_manual(values = type.color) +
  theme_bw() +
  theme(legend.position = c(.92,.22),
        legend.background = element_rect(fill = "transparent", colour = "transparent"))
p2 <- ggplot(fitness.diff, aes(x = gen, y = diff_bva, colour = bva_density)) +
  geom_point(alpha = 0.25) + 
  scale_color_viridis() +
  xlab("Generation") + ylab("Difference of Fitness") + labs(colour = "Density") +
  ylim(0,0.18) +
  ggtitle("Breast vs Alzheimer's Disease") +
  theme_bw() 

p3 <- ggplot(fitness.diff, aes(x = gen, y = diff_bvc, colour = bvc_density)) +
  geom_point(alpha = 0.25) + 
  scale_color_viridis() +
  xlab("Generation") + ylab("Difference of Fitness") + labs(colour = "Density") +
  ylim(0,0.18) +
  ggtitle("Breast vs Control") +
  theme_bw() 

library(ggridges)
p4 <- ggplot(lastgen, aes(x = fitness, y = type, fill = type)) + geom_density_ridges(alpha = 0.5) +
  xlab("Fitness Score") + ylab("") + guides(fill = FALSE) +
  scale_fill_manual(values = type.color) +
  ggtitle("Distribution of Fitness Scoress - Generation 100") +
  theme_bw()

library(patchwork)
layout <- "A\nA\nB\nC\nD\nD"
dev.off()
combined.plot <- p1 + p2 + p3 + p4 + plot_layout(design = layout)
ggsave(filename = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/figure/breast_alz_ctrl_fitness_compare.png", width = 12, height = 12)
```

## Get OF hits 
```{r}
rm(list = ls(all.names = T)); gc()
## Load prereq data
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/ctrl.gp.prereq.rda")

## Load final res
load("/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_ld_multi.run_121323.rda")
test.run <- multi.gp[[2]]
top.proposal <- test.run[["proposal"]]
loci <- 174
genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))

## What objective function are we interested in?
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac")


data <- result %>% dplyr::select(locus, gene, celltype)
get.of.hits <- function(data, obj.fun) { ## Data is df of locus, gene and cell type; obj.fun is a vector of OF to use
  obj.fun.hit <- list()
  ########################################
  ## Combined gene marker - CEVM and FM ##
  if("marker.gene" %in% obj.fun) {
    marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
      
    marker.gene.obj <- data %>% left_join(x = ., y = marker.gene, by = c("gene", "celltype")) %>%
      mutate(marker.gene = replace_na(marker.gene, replace = 0))
    obj.fun.hit[["marker.gene"]] <- as.data.frame(marker.gene.obj)
    } ## End of combined gene marker
  
  ###########
  ## Magma ##
  if("magma" %in% obj.fun) {
  magma.obj <- data %>% left_join(x = ., y = magma, by = "gene") %>%
    mutate(magma = replace_na(magma, replace = 0))
  obj.fun.hit[["magma"]] <- as.data.frame(magma.obj)
  } ## End of magma

  ##########################
  ## Highly mutated genes ##
  if("hi.mut" %in% obj.fun) {
    hi.mut.obj <- data %>% left_join(x = ., y = breast.cancer.gene, by = "gene") %>%
      mutate(cancer.gene = replace_na(cancer.gene, replace = 0))
    obj.fun.hit[["hi.mut"]] <- as.data.frame(hi.mut.obj)
  } ## End of hi mut
  
  ############################
  ## PPI Objective Function ##
  if(any(c("ppi", "intra.ppi", "inter.ppi", "marker.ppi", "go.cc.ppi") %in% obj.fun)) {
    match.set <- ppi %>% left_join(x = ., y = data, by = c("gene1"="gene"),
                                   relationship = "many-to-many") %>%
      dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
      left_join(x = ., y = data, by = c("gene2"="gene"),
                relationship = "many-to-many") %>%
      dplyr::rename("celltype2"="celltype", "locus2"="locus") %>%
      na.omit()
    if("intra.ppi" %in% obj.fun) {
       intra.df <-  match.set %>% mutate(intra.commun = case_when(celltype1 == celltype2 ~ 1,
                                                                  celltype1 != celltype2 ~ 0)) %>%
          ## Label each cases as 1 or 0 for having same celltype or not, then filter for 1.
          dplyr:::filter(intra.commun == 1) %>%
          group_by(grp = paste(pmax(gene1, gene2), ## Keep only intra combo (no celltalk combo)
                               pmin(gene1, gene2), sep = "_")) %>%
          dplyr::filter(!grp %in% celltalk_gene$grp) %>%
          ungroup() %>%
          dplyr::select(-grp) %>%
          distinct()
       if(nrow(intra.df) > 0) {
            intra.df <- data.frame(gene = unique(c(intra.df$gene1, intra.df$gene2)),
                                          intra.ppi = 1)
            ##
            intra.res <- data %>% left_join(x = ., y = intra.df, by = "gene") %>%
              mutate(intra.ppi = replace_na(intra.ppi, replace = 0))
          } else {
            intra.res <- data %>% mutate(intra.ppi = 0)
          }
       obj.fun.hit[["intra.ppi"]] <- as.data.frame(intra.res)
    } ## End of intra.ppi
    
    ##############
    ## PPI Only ##
    if("ppi" %in% obj.fun) {
      ppi.genes <- data.frame(gene = unique(c(match.set$gene1, match.set$gene2)),
                                  ppi = 1)
      ppi.res <- data %>% left_join(x = ., y = ppi.genes, by = "gene") %>%
        mutate(ppi = replace_na(ppi, replace = 0))
      obj.fun.hit[["ppi"]] <- as.data.frame(ppi.res)
    } ## End of PPI 
    
    #####################
    ## marker ppi only ##
    if("marker.ppi" %in% obj.fun) {
      all.markers <- combined.gene.marker %>% mutate(marker.gene = 1) %>% distinct()
      
      marker.obj <- match.set %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit()
      
      if(nrow(marker.obj) == 0) {
          marker.res <- data %>% mutate(marker.ppi = 0)
      } else {
        df1 <- marker.obj %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
        df2 <- marker.obj %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
        marker.ppi.set <- rbind(df1, df2) %>% mutate(marker.ppi = 1) %>% distinct()
        
        marker.res <- data %>% left_join(x = ., y = marker.ppi.set, by = c("gene", "celltype")) %>%
                mutate(marker.ppi = replace_na(marker.ppi, replace = 0))
      }
      obj.fun.hit[["marker.ppi"]] <- as.data.frame(marker.res)
    } ## End of marker ppi
    
    ###############
    ## Inter ppi ##
    if("inter.ppi" %in% obj.fun) {
      all.markers <- combined.gene.marker %>% mutate(marker.gene = 1) %>% distinct()
      marker.obj <- match.set %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
        left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
        na.omit() %>% ## Keep positive hits.
        dplyr::select(-marker.gene.x, -marker.gene.y) ## Get rid of columns no longer needed
      if(nrow(marker.obj) == 0) {
          inter.ppi.obj <- data %>% mutate(inter.ppi = 0)
      } else {
        inter.obj <- marker.obj %>% left_join(x = ., 
                                                y = celltalkdb[,c("source_genesymbol", "inter.ppi")], 
                                                by = c("gene1"="source_genesymbol"),
                                                relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("source_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("source_genesymbol", "inter.ppi")],
                      by = c("gene2"="source_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>% 
            dplyr::rename("source_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("source_gene1", "source_gene2")], na.rm = TRUE) == 1),] %>%
          
            ## Now trying to find targets the same way we did for source genes
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene1"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene2"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("target_gene1", "target_gene2")], na.rm = TRUE) == 1),] %>%
            ## Removing target and source identity column
            dplyr::select(-source_gene1, -source_gene2, -target_gene1, -target_gene2)
        if(nrow(inter.obj) == 0) {
          inter.ppi.obj <- data %>% mutate(inter.ppi = 0)
        } else {
          df1 <- inter.obj %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          df2 <- inter.obj %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          inter.ppi.set <- rbind(df1, df2) %>% mutate(inter.ppi = 1) %>% distinct()
          
          inter.ppi.obj <- data %>% left_join(x = ., y = inter.ppi.set, by = c("gene", "celltype")) %>%
              mutate(inter.ppi = replace_na(inter.ppi, replace = 0))
        }
      }
      obj.fun.hit[["inter.ppi"]] <- as.data.frame(inter.ppi.obj)
    } ## End of inter.ppi
  } ## End of all PPI function
  
  #################################
  ## Promoter Objective Function ##
  if("promoter" %in% obj.fun) {
    promoter.obj <- data %>% left_join(x = ., y = promoter.df, by = c("locus", "gene")) %>%
      mutate(promoter = replace_na(promoter, replace = 0)) 
      
      obj.fun.hit[["promoter"]] <- promoter.obj
    } ## End of promoter
  
  #############################
  ## ATAC Objective Function ##
  ## Marker atac peak 
  if("marker.atac" %in% obj.fun) {
    m.atac.obj <- data %>% left_join(x = ., y = atac.marker, by = c("locus", "celltype")) %>%
      mutate(marker.atac = replace_na(marker.atac, replace = 0))
    
    obj.fun.hit[["marker.atac"]] <- m.atac.obj
  } ## End of marker atac
  ## Common atac peak
    if("common.atac" %in% obj.fun) {
      c.atac.obj <- data %>% left_join(x = ., y = common.atac.hit, by = c("locus", "celltype")) %>%
        mutate(common.atac = replace_na(common.atac, replace = 0)) 
      obj.fun.hit[["common.atac"]] <- c.atac.obj
    } ## End of common atac
  
  ########################
  ## lncrna interaction ##
  if("lncrna.ppi" %in% obj.fun) {
    ## Match proposal elements with ppi
    match.set <- rna.protein.map %>% left_join(x = ., y = data, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = data, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit()
    
    if(nrow(match.set)==0) { ## If match.set is 0. meaning no lncrna and protein interactions
      lncrna.res <- data %>% mutate(lncrna = 0)
    } else { ## If there is a match then do the following
      lncrna.genes <- data.frame(gene = unique(c(match.set$gene1, match.set$gene2)),
                                lncrna = 1)
      lncrna.res <- data %>% left_join(x = ., y = lncrna.genes, by = "gene") %>%
          mutate(lncrna = replace_na(lncrna, replace = 0))
    }
      
    obj.fun.hit[["lncrna.ppi"]] <- lncrna.res
    } ## end of lncrna
  
  ## Combine the obj.fun.hit together 
  for(n in 1:length(obj.fun)) {
    if(n == 1) {
      obj.hits <- obj.fun.hit[[obj.fun[n]]]
      } else {
        add_test <- obj.fun.hit[[obj.fun[n]]]
        obj.hits <- left_join(x = obj.hits, y = add_test, by = c("locus", "gene", "celltype"))
      }
  }
  
  ## Return final res
  return(obj.hits)
} ## End of function

c_res <- get.of.hits(data = data, obj.fun = obj.fun)      
#save(c_res, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/c_res.rda")
    
```

BRCA OF hits
```{r}
rm(list = ls(all.names = T)); gc()
## Make sure to run the get.of.hits function in the previous chunk
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)

load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/brca.gp.prereq.rda")

load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_110723.rda")
test.run <- multi.gp[[3]]
top.proposal <- test.run[["proposal"]]
loci <- length(top.proposal)/1000
genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))

## What objective function are we interested in?
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac")

data <- result %>% dplyr::select(locus, gene, celltype)
## Pretty much run the same chucks but with breast data from brca_gp.Rmd

b_res <- get.of.hits(data = data, obj.fun = obj.fun)      
#save(b_res, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/b_res.rda")

```

Alzheimer OF hits
```{r}
rm(list = ls(all.names = T)); gc()
## Make sure to run the get.of.hits function in the previous chunk
load("/drive-pool/data/peter_data/genetic_programming/alz_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)

load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/alz.gp.prereq.rda")

load("/drive-pool/data/peter_data/genetic_programming/code/brca/alz_ld_multi.run_120623.rda")
alz_data <- multi.gp[[1]]; rm(multi.gp)
top.proposal <- alz_data[["proposal"]]
loci <- nrow(top.proposal)/1000
genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))

## What objective function are we interested in?
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac")

data <- result %>% dplyr::select(locus, gene, celltype)
## Pretty much run the same chucks but with breast data from brca_gp.Rmd

a_res <- get.of.hits(data = data, obj.fun = obj.fun)      
save(a_res, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/a_res.rda")

```

Run Chi-square on control and brca result
```{r}
rm(list = ls(all.names = T)); gc()

## Load breast and control result
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/b_res.rda")
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/c_res.rda")

b_data <- b_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(b_res) - hits,
         type = "breast")

c_data <- c_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(c_res) - hits,
         type = "control")

## Check whether observed vs expected is statistically significantly diff

of.chisq.res <- list()

for(n in rownames(b_data)) {
  breast <- as.numeric(b_data[which(rownames(b_data) == n), c(1:2)])
  ctrl <- as.numeric(c_data[which(rownames(c_data) == n), c(1:2)])
  
  chi.res <- chisq.test(data.frame(breast,ctrl))
  
  res <- data.frame(obj.fun = n,
                    obs.hits = breast[1],
                    obs.nohits  = breast[2],
                    exp.hits = ctrl[1],
                    exp.nohits = ctrl[2],
                    pval = chi.res$p.value)
  
  of.chisq.res[[n]] <- res
}

of.chisq.res <- as.data.frame(do.call(rbind, of.chisq.res))
of.chisq.res$padj <- p.adjust(of.chisq.res$pval, "BH") ## multiple hypothesis correction
of.chisq.res$signif <- case_when(of.chisq.res$padj >= 0.05 ~ 0, ## Convert padj to boolean value. FDR is set to 0.05
                                 of.chisq.res$padj < 0.05 ~ 1)
```

Code block for storing results from the follow 3 chunks below
```{r}
beta.compare.res <- list()

## See the 4th block after this one for the rest of the code
```


Run Beta distribution test on control and brca result
```{r}
#rm(list = ls(all.names = T)); gc()

## Load breast and control result
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/b_res.rda")
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/c_res.rda")

b_data <- b_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(b_res) - hits,
         type = "breast")

c_data <- c_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(c_res) - hits,
         type = "control")

rm(c_res, b_res); gc()

## Check whether observed vs expected is statistically significantly diff

of_beta_res <- list() ## store results from beta distribution
CI <- 0.025 ## confidence interval
n.sim <- 1e5

for(n in rownames(b_data)) {
  ## Get res from individual obj function
  breast <- as.numeric(b_data[which(rownames(b_data) == n), c(1:2)])
  ctrl <- as.numeric(c_data[which(rownames(c_data) == n), c(1:2)])
  
  fg_rbeta <- rbeta(n = n.sim, shape1 = breast[1], shape2 = breast[2])
  bg_rbeta <- rbeta(n = n.sim, shape1 = ctrl[1], shape2 = ctrl[2])
  
  beta.res <- fg_rbeta - bg_rbeta
  
  
  quant_diff <- quantile(beta.res, c(CI, 0.5, 1-CI))
  pval <- sum(beta.res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
  
  res <- data.frame(obj.fun = n,
                    fg.hits = breast[1],
                    fg.nohits  = breast[2],
                    bg.hits = ctrl[1],
                    bg.nohits = ctrl[2],
                    lower.ci = round(quant_diff[1], 3),
                    median = round(quant_diff[2], 3),
                    upper.ci = round(quant_diff[3], 3),
                    n = n.sim,
                    fglessbg = sum(beta.res < 0),
                    pval = pval,
                    group = "breastvsctrl")
  
  of_beta_res[[n]] <- res
  
}

of_beta_res <- as.data.frame(do.call(rbind, of_beta_res))
of_beta_res$padj <- p.adjust(of_beta_res$pval, "BH") ## multiple hypothesis correction
of_beta_res$signif <- case_when(of_beta_res$padj >= 0.05 ~ 0, ## Convert padj to boolean value. FDR is set to 0.05
                                of_beta_res$padj < 0.05 ~ 1)
of_beta_res$cross.zero <- case_when(of_beta_res$lower.ci <= 0 ~ 1,
                                    of_beta_res$lower.ci > 0 ~ 0)
rownames(of_beta_res) <- NULL
of_beta_res

beta.compare.res[[1]] <- of_beta_res
```

Run Beta distribution test on control and alz result
```{r}
#rm(list = ls(all.names = T)); gc()

## Load alz and control result
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/a_res.rda")
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/c_res.rda")

a_data <- a_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(a_res) - hits,
         type = "alzheimer")

c_data <- c_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(c_res) - hits,
         type = "control")

rm(c_res, a_res); gc()

## Check whether observed vs expected is statistically significantly diff

of_beta_res <- list() ## store results from beta distribution
CI <- 0.025 ## confidence interval
n.sim <- 1e5

for(n in rownames(a_data)) {
  ## Get res from individual obj function
  alzheimer <- as.numeric(a_data[which(rownames(a_data) == n), c(1:2)])
  ctrl <- as.numeric(c_data[which(rownames(c_data) == n), c(1:2)])
  
  fg_rbeta <- rbeta(n = n.sim, shape1 = alzheimer[1], shape2 = alzheimer[2])
  bg_rbeta <- rbeta(n = n.sim, shape1 = ctrl[1], shape2 = ctrl[2])
  
  beta.res <- fg_rbeta - bg_rbeta
  
  
  quant_diff <- quantile(beta.res, c(CI, 0.5, 1-CI))
  pval <- sum(beta.res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
  
  res <- data.frame(obj.fun = n,
                    fg.hits = alzheimer[1],
                    fg.nohits  = alzheimer[2],
                    bg.hits = ctrl[1],
                    bg.nohits = ctrl[2],
                    lower.ci = round(quant_diff[1], 3),
                    median = round(quant_diff[2], 3),
                    upper.ci = round(quant_diff[3], 3),
                    n = n.sim,
                    fglessbg = sum(beta.res < 0),
                    pval = pval,
                    group = "alzheimervsctrl")
  
  of_beta_res[[n]] <- res
  
}

of_beta_res <- as.data.frame(do.call(rbind, of_beta_res))
of_beta_res$padj <- p.adjust(of_beta_res$pval, "BH") ## multiple hypothesis correction
of_beta_res$signif <- case_when(of_beta_res$padj >= 0.05 ~ 0, ## Convert padj to boolean value. FDR is set to 0.05
                                of_beta_res$padj < 0.05 ~ 1)
of_beta_res$cross.zero <- case_when(of_beta_res$lower.ci <= 0 ~ 1,
                                    of_beta_res$lower.ci > 0 ~ 0)
rownames(of_beta_res) <- NULL
of_beta_res

beta.compare.res[[2]] <- of_beta_res
```

Run Beta distribution test on alzheimer and breast result
```{r}
#rm(list = ls(all.names = T)); gc()

## Load alz and control result
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/a_res.rda")
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/b_res.rda")

a_data <- a_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(a_res) - hits,
         type = "alzheimer")

b_data <- b_res %>% dplyr::select(-locus, -gene, -celltype) %>% 
  colSums() %>% as.data.frame() %>%
  dplyr::rename("hits" = ".") %>%
  mutate(no_hits = nrow(b_res) - hits,
         type = "breast")

rm(b_res, a_res); gc()

## Check whether observed vs expected is statistically significantly diff

of_beta_res <- list() ## store results from beta distribution
CI <- 0.025 ## confidence interval
n.sim <- 1e5

for(n in rownames(a_data)) {
  ## Get res from individual obj function
  alzheimer <- as.numeric(a_data[which(rownames(a_data) == n), c(1:2)])
  breast <- as.numeric(b_data[which(rownames(b_data) == n), c(1:2)])
  
  fg_rbeta <- rbeta(n = n.sim, shape1 = breast[1], shape2 = breast[2])
  bg_rbeta <- rbeta(n = n.sim, shape1 = alzheimer[1], shape2 = alzheimer[2])
  
  beta.res <- fg_rbeta - bg_rbeta
  
  
  quant_diff <- quantile(beta.res, c(CI, 0.5, 1-CI))
  pval <- sum(beta.res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
  
  res <- data.frame(obj.fun = n,
                    fg.hits = breast[1],
                    fg.nohits  = breast[2],
                    bg.hits = alzheimer[1],
                    bg.nohits = alzheimer[2],
                    lower.ci = round(quant_diff[1], 3),
                    median = round(quant_diff[2], 3),
                    upper.ci = round(quant_diff[3], 3),
                    n = n.sim,
                    fglessbg = sum(beta.res < 0),
                    pval = pval,
                    group = "breastvsalzheimer")
  
  of_beta_res[[n]] <- res
  
}

of_beta_res <- as.data.frame(do.call(rbind, of_beta_res))
of_beta_res$padj <- p.adjust(of_beta_res$pval, "BH") ## multiple hypothesis correction
of_beta_res$signif <- case_when(of_beta_res$padj >= 0.05 ~ 0, ## Convert padj to boolean value. FDR is set to 0.05
                                of_beta_res$padj < 0.05 ~ 1)
of_beta_res$cross.zero <- case_when(of_beta_res$lower.ci <= 0 ~ 1,
                                    of_beta_res$lower.ci > 0 ~ 0)
rownames(of_beta_res) <- NULL
of_beta_res

beta.compare.res[[3]] <- of_beta_res
```

Code block for storing results from the follow 3 chunks below (continued)
```{r}
beta.compare.res <- as.data.frame(do.call(rbind,beta.compare.res))

beta.compare.res %>% dplyr::select(-n)
```

