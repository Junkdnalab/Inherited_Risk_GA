---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
## PMID 33270826
## Using sampling tool to get random background

## Will be sampling based on the following criteria
## Distance from TSS
## Gene density
## Number of LD
```

Calculate Gene Density
```{r}
rm(list = ls(all.names = T)); gc()
## Prep data for finding nearest genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda") ## gene annotation
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda") ## Finemap snp

## Simply df to only include relevant column. Also, add column to say what SNPs have LD
snps.df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS, SNP_ID_CURRENT) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS", "SNP_id"="SNP_ID_CURRENT") %>% ## Rename columns
  mutate(seqnames = paste0("chr", seqnames), ## add chr before chromosome id
         LD = 0) %>% ## LD is 0 because we are not adding LD into the mix atm
  distinct()

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.

gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- NULL ## Setting min genes to NULL. We are interested in the gene density with a 200kb window

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)

rm(list=setdiff(ls(), "nearbygenes_10xgenomics")) ## remove everything except nearbygenes

as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  ggplot(data = ., aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Total ngenes") + ylab("Density") +
  ggtitle(paste0("Number of Genes per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

## Based on the results, the deviation that will be used for vsampler for gene density is 20.
```

Calculate distance from TSS 
```{r}
## Create empty vector 
dist.nearby <- vector(mode = "numeric",
                      length = length(unique(nearbygenes_10xgenomics$snp)))

counter <- 1
for(n in unique(nearbygenes_10xgenomics$snp)) { ## loop through each snp and get closest gene to snp length
  p <- nearbygenes_10xgenomics %>% dplyr::filter(snp == n) %>% 
    pull(distance_tss) %>% abs() %>% ## get distance column and take absolute value
    min()
  dist.nearby[counter] <- p
  
  ## add counter to move to next vector
  counter <- counter + 1
}

dist.nearby <- data.frame(x = dist.nearby)
ggplot(data = dist.nearby, aes(x = x)) +
  geom_density() +
  theme_minimal() +
  xlab("Distance to TSS") + ylab("Density") +
  ggtitle(paste0("Closest Distance to TSS per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

## Based on the results, the deviation that will be used for vsampler for distance from tss is 100k.
```

Calculate number of LD per SNP
```{r}

load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")

n.ld <- as.data.frame(table(ld$LEAD_SNP))

ggplot(data = n.ld, aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Number of SNPs in LD") + ylab("Density") +
  ggtitle(paste0("Number of SNPs in LD per SNP - "))

## Based on the results, the deviation that will be used for vsampler for number of SNPs in LD is 100.
```

Running vsampler with values determined by chunks above
```{r}
## Need to get SNPs id / Chromosome ID and POS for snps for matching
## Will use coordinates because variants don't have RSID.
#rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda"); rm(gwas_catalog) ## Finemap snp

df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS) %>%
  distinct()

write.table(x = df, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vsampler_input_breast.txt",
            row.names = FALSE,
            col.names = FALSE,
            sep = "\t",
            quote = FALSE)

## Ran vsampler using webserver on Dec 11 2023

vs_out <- fread("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vsampler/anno.out.txt")

n_query <- length(which(vs_out$LABEL == "query"))
## Because there is 10 controls for every query, I have to make a column so I can filter for specific query and matched controls
vs_out$GROUP <- rep(1:n_query, each = 11)

vs_controls <- list() 

for(n in 1:3) { ## Get 3 control sets
  vs_controls[[n]] <- vs_out %>%
    dplyr::filter(LABEL != "query") %>%
    dplyr::group_by(GROUP) %>%
    slice_sample(n = 1)
}  

save(vs_controls, file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda")

## Compare Gene Density
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  gd.control <- data.frame(type = p,
                         ngene = df$Gene_Dis_KB200)
  if(n == 1) {
    res <- gd.control
  } else {
    res <- rbind(res, gd.control)
  }
}

gd.brca <- as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  'colnames<-' (c("type", "ngene")) %>%
  mutate(type = "brca")

gd.plotdata <- rbind(gd.brca, res)

p1 <- ggplot(data = gd.plotdata, aes(x = ngene, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Gene Density") + ylab("Density") 

## Compare Distance to TSS
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  tss.control <- data.frame(type = p,
                            tss = df$DTCT)
  if(n == 1) {
    res <- tss.control
  } else {
    res <- rbind(res, tss.control)
  }
}

tss.brca <- data.frame(type = "brca",
                      tss = dist.nearby$x)

tss.plotdata <- rbind(tss.brca, res)

p2 <- ggplot(data = tss.plotdata, aes(x = tss, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Distance to TSS") + ylab("Density") 

## Compare Number of LD
for(n in 1:3) {
  p <- paste0("control_",n)
  df <- vs_controls[[n]]
  ld.control <- data.frame(type = p,
                            ld = df$inLDvariants_LD6)
  if(n == 1) {
    res <- ld.control
  } else {
    res <- rbind(res, ld.control)
  }
}

ld.brca <- data.frame(type = "brca",
                      ld = n.ld$Freq)

ld.plotdata <- rbind(ld.brca, res)

p3 <- ggplot(data = ld.plotdata, aes(x = ld, colour = type)) +
  geom_density() +
  theme_minimal() + 
  xlab("Number of SNPs in LD") + ylab("Density") 


## Combine plots together
layout <- "ABC" ## plot layout

combined.p <- p1 + p2 + p3 + plot_layout(design = layout, guides = "collect")
dev.off()
ggsave(file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/figure/rand.control.characteristic.png",
       width = 14,
       height = 7)
```

## Prepare random control for GA model
```{r}
rm(list = ls(all.names = T)); gc()
## There are 3 sets of column in here. Just gonna randomly choose 1
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda") 
set.seed(514)
x <- sample(x = 1:3, size = 1)

ctrl <- vs_controls[[x]] ## Select control
rm(vs_controls, x); gc()

data <- ctrl %>% dplyr::select(CHR, POS, LABEL) %>%
  dplyr::rename("CHR_ID"="CHR", "CHR_POS"="POS", "SNP_ID_CURRENT"="LABEL") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID),
         SNP_ID_CURRENT = paste0(SNP_ID_CURRENT, "_", rownames(.))) %>%
  distinct()
```

Get SNPs in LD
```{r}
library(LDlinkR)


## Because there's no rsid. will be using coord
## Setup looks like this chr7:24966446
snps <- paste0(data$CHR_ID,":",data$CHR_POS)
counter <- 1
## Creating list to store res from for loop below. LDproxy does not like multi queries
ldproxy_res <- list()

## For loop to find snps in proxy to the lead snp
for(snp in snps) {
  message("Working on snp",counter, ": ", snp)
  
  res <- LDproxy(
    snp = snp,
    pop = c("CEU", "TSI", "GBR", "IBS"), ## All european pop
    r2d = "r2",
    token = "9dfb615d7a15", ## Unique token. Need to register on ldlink to get your own token
    file = FALSE,
    genome_build = "grch38",
    api_root = "https://ldlink.nih.gov/LDlinkRest"
  )
  res$snp <- snp
  ## Update counter: counter is for knowing where it is.
  counter <- counter + 1
  ldproxy_res[[snp]] <- res
}

## Identify snps that did not have any snp in ld with it
rm.res <- data.frame(ncol = sapply(ldproxy_res, ncol)) %>% dplyr::filter(ncol == 2) %>% rownames() ## Nothing to remove
#ldproxy_res <- ldproxy_res[!names(ldproxy_res) %in% rm.res]

ldproxy_res <- as.data.frame(do.call(rbind, ldproxy_res)) %>% remove_rownames()
save(ldproxy_res, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_snpLDproxy.rda")
```

Get nearby genes based on lead SNPs and in LD
```{r}
## Load ctrl SNP
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_snpLDproxy.rda")
## Filter ld proxy for snps with an R2 of 0.9 and MAF of 0.05 or greater
ld <- ldproxy_res %>% dplyr::filter(R2 >= 0.6,
                                    Dprime >= 0.9) %>%
  dplyr::select(RS_Number, Coord, snp, Alleles, Distance)
rm(ldproxy_res); gc()
## There are cases where the RS_number and snp (lead snp) are the same. Dont know why, but remove those cases.
if(any((ld$RS_Number == ld$snp))) {
  ld <- ld[-which(ld$RS_Number == ld$snp),] 
}

## Some snps dont have rsid, just coord. Lets add corrd to rsid for those cases
ld[which(ld$RS_Number == "."), "RS_Number"] <- ld[which(ld$RS_Number == "."), "Coord"]

ld <- ld %>% separate(Coord, c("CHR_ID", "CHR_POS"), sep = ":") %>%
  mutate(CHR_ID = gsub(pattern = ".*chr", replacement = "", x = CHR_ID)) %>%
  dplyr::rename("SNPS"="RS_Number", "LEAD_SNP"="snp")

## Simply df to only include relevant column. Also, add column to say what SNPs have LD 
snps.df <- data %>% ungroup() %>% dplyr::select(CHR_ID, CHR_POS) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS") %>% ## Rename columns
  mutate(SNP_id = paste0(seqnames,":",start)) %>%
  left_join(x = ., ## What lead SNPs have snps in ld
            y = data.frame(SNP_id = unique(ld$LEAD_SNP),
                           LD = 1),
            by = "SNP_id") %>%
  mutate(LD = replace_na(LD, replace = 0))

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.
ldsnps.range <- ld %>% dplyr::group_by(LEAD_SNP) %>%
  dplyr::summarise(min = min(CHR_POS),
                   max = max(CHR_POS))

load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")
gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- 10 ## Set the min ngenes a lead snp should have. only needed when elmer.style is false

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)
save(nearbygenes_10xgenomics, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
```

Generate obj function for control match
```{r}
load("/drive-pool/data/peter_data/genetic_programming/alz_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics); gc()

#######################################################
## Need to update some obj function for the alz snps ##

## First one is ATAC data
## Make gwas snps into granges
## Get all snps (lead snp +  ld)
all.snps <- data[,c("CHR_ID", "CHR_POS")] %>%
  mutate(SNPS = paste0(CHR_ID, ":", CHR_POS)) %>%
  mutate(CHR_ID = gsub(pattern = "chr\\.*", replacement = "", x = .$CHR_ID)) %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

load("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/PeakCalls/markerList.rda")

celltype <- names(markerList@listData)
atac.marker <- list()

for(n in celltype) {
  marker.df <- as.data.frame(markerList@listData[[n]])
  if(nrow(marker.df) <= 1) { ## If there are no markers for celltype then skip
    next
  } else {
    p <- unlist(strsplit(x = n, split = " "))[1] ## Get only celltype name. Don't care about CF at the end
    ## Get atac-seq probes and make into granges
    marker.granges <- GRanges(seqnames = Rle(marker.df$seqnames),
                              range = IRanges(start = marker.df$start,
                                              end = marker.df$end),
                              idx = marker.df$idx)
    marker.granges <- unique(marker.granges)
    ## Find overlaps between snp and atac region
    hits <- findOverlaps(query = gwas, subject = marker.granges)
    ## Extract results
    # marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
    #   dplyr::select(locus) %>% distinct() %>%
    #   mutate(celltype = p)
    marker.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                        as.data.frame(marker.granges) %>% .[hits@to,]) %>%
      .[,6:13] %>% remove_rownames() %>%
      mutate(celltype = p)
    atac.marker[[p]] <- marker.hit
  }
}
atac.marker <- as.data.frame(do.call(rbind, atac.marker)) %>% remove_rownames() %>%
  mutate(atac = 1) %>% 
  dplyr::select(locus, celltype, atac) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
atac.marker[which(is.na(atac.marker$LEAD_SNP)), "LEAD_SNP"] <- atac.marker[which(is.na(atac.marker$LEAD_SNP)), "locus"]

save(atac.marker, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")   
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")
#######################
## Common atac peaks ##

#######################################
## Finding Common Peaks in ATAC data ##
loadArchRProject("/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/")
projCis <- readRDS(file = "/drive-pool/data/peter_data/sc_data/brca/GSE168837/arrowFiles/Save-projCis/Save-ArchR-Project.rds")

## Checking to see available matrix in data
# getAvailableMatrices(projCis)

## Getting peaks by cell type
peakset <- getPeakSet(projCis)
names(peakset) <- NULL

## Make gwas snps into granges
gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

hits <- findOverlaps(query = gwas, subject = peakset)
## Extract results
# marker.hit <- as.data.frame(gwas) %>% .[hits@from,] %>% remove_rownames() %>% 
#   dplyr::select(locus) %>% distinct() %>%
#   mutate(celltype = p)
common.atac.hit <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                    as.data.frame(peakset) %>% .[hits@to,]) %>% 
  remove_rownames() %>%
  dplyr::select(locus, GroupReplicate, peakType, nearestGene, distToGeneStart, distToTSS) %>% 
  mutate(GroupReplicate = gsub(pattern = "\\s.*", replacement = "", x = GroupReplicate),
         common.atac = 1) %>%
  distinct() %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "LEAD_SNP"] <- common.atac.hit[which(is.na(common.atac.hit$LEAD_SNP)), "locus"] 

save(common.atac.hit, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")

##############
## Promoter ##

## Get atac-seq probes and make into granges
genes.granges <- GRanges(seqnames = Rle(nearbygenes$seqnames),
                       range = IRanges(start = nearbygenes$tss),
                       gene = nearbygenes$gene_name)
genes.granges <- unique(genes.granges)

promoter.granges <- promoters(genes.granges, upstream = 1000, downstream = 100)

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))
## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = promoter.granges)

promoter.df <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(promoter.granges) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  mutate(promoter = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
promoter.df[which(is.na(promoter.df$LEAD_SNP)), "LEAD_SNP"] <- promoter.df[which(is.na(promoter.df$LEAD_SNP)), "locus"]
save(promoter.df, file = "/drive-pool/data/peter_data/genetic_programming/ctrl_ld_promoter.df.rda")
```

Genetic Algorithm
```{r}
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
## Load ctrl data
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/code/vs_controls.rda") 
set.seed(514)
x <- sample(x = 1:3, size = 1)

ctrl <- vs_controls[[x]] ## Select control
rm(vs_controls, x); gc()

data <- ctrl %>% ungroup() %>% dplyr::select(CHR, POS) %>%
  dplyr::rename("CHR_ID"="CHR", "CHR_POS"="POS") %>%
  mutate(CHR_ID = paste0("chr", CHR_ID),
         SNP_ID_CURRENT = paste0(CHR_ID, ":", CHR_POS)) %>%
  distinct()

#load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda") ## marker genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda"); rm(marker.list); gc()
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_promoter.df.rda")
promoter.df <- promoter.df %>% mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cevm.rda")
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac.marker.rda")
atac.marker <- atac.marker %>% dplyr::rename("marker.atac"="atac") %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
## Merge fusion.gene with breast.cancer.gene
fusion.gene <- fusion.gene %>% dplyr::rename("cancer.gene"="fusion") ## Rename colname for rbind
breast.cancer.gene <- rbind(breast.cancer.gene, fusion.gene) ## rbind together
breast.cancer.gene <- distinct(breast.cancer.gene); rm(fusion.gene) ## Keep unique observation
#load("/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
load("/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
celltalkdb$inter.ppi <- 1 ## Add 
load("/drive-pool/data/peter_data/genetic_programming/ctrl_ld_atac_peak.rda")
common.atac.hit <- common.atac.hit %>% dplyr::select(locus, GroupReplicate, LEAD_SNP) %>%
  dplyr::rename("celltype"="GroupReplicate") %>%
  mutate(common.atac = 1) %>%
  distinct() %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()


loci2gene <- nearbygenes %>% dplyr::select(snp, gene_name) %>% 
  remove_rownames() %>%
  dplyr::rename("cytoband"="snp") %>%
  distinct()

loci <- unique(loci2gene$cytoband) 

###########################################
## Gene Ontology Cellular Component Prep ##
go_gene <- map.go.gene %>% dplyr::filter(external_gene_name %in% loci2gene$gene_name)
## There is 1844 unique genes in loci2gene, but only 741 mapped with map.go.gene. Why? Naming issue? Lets check
# check.gene <- checkGeneSymbols(unique(map.go.gene$external_gene_name)) %>%
#   dplyr::filter(x != "")
# updated.gene <- check.gene %>% dplyr::filter(Approved == FALSE)
## It's just not mapped to it. Tried updating the gene symbol but no additional matches
#table(go_gene$external_gene_name %in% unique(geneAnnot.df$gene_name))
## Check the original gtf file and all genes from go_gene is present.
## Just the snp doesn't hit those genes. Moving forward.

#############################################
## Highly Mutated/Cancer Driver Genes Prep ##
# breast.cancer.gene

# table(breast.cancer.gene$gene %in% unique(loci2gene$gene_name)) ## Only 20 genes map to loci2gene why?
## Checking to see if gene has updated symbol
# check.gene <- checkGeneSymbols(unique(breast.cancer.gene$gene))
# table(check.gene$Approved == FALSE) ## 185 have the most uptodate gene symbol...
## Lets check loci2gene
# check.gene <- checkGeneSymbols(unique(loci2gene$gene_name)) %>% dplyr::filter(Approved == FALSE) 
## Nope. Most genes with FALSE for approved are noncoding rna. and the very few with updates, they aren't found in breast.cancer.gene.
## So it's really only 20 genes for highly mutated genes/ cancer genes based on these snps
## Check the original gtf file and 186 of 190 genes from breast cancer gene is present.
## Again, just the snp doesn't hit those genes. Moving forward.

############
## PPI df ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
## Update the link data to have gene symbol
str.db.link <- str.db.link %>% dplyr::select(protein1, protein2, experiments, 
                                             experiments_transferred, combined_score) %>%
  left_join(x = ., y = str.db.info, by = c("protein1"="string_id")) %>%
  dplyr::rename("gene1"="gene_symbol") %>%
  left_join(x = ., y = str.db.info, by = c("protein2"="string_id")) %>%
  dplyr::rename("gene2"="gene_symbol") %>%
  .[,c("protein1", "protein2", "gene1", "gene2", "experiments", "experiments_transferred", "combined_score")]

ppi <- str.db.link %>% dplyr::select(gene1, gene2) %>%
  dplyr::filter(gene1 %in% map.genes$gene_name, 
                gene2 %in% map.genes$gene_name) %>% ## Filter for specific genes found in gwas 200kb
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct(); rm(str.db.info, map.genes, str.db.link); gc()


## Prepare intra.cellular ppi
## Remove gene combo found in celltalkdb
celltalk_gene <- celltalkdb %>% dplyr::select(source_genesymbol, target_genesymbol) %>%
  dplyr::rename("gene1"="source_genesymbol", "gene2"="target_genesymbol") %>%
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_"))
  
intra.ppi.gene <- ppi %>% 
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(!grp %in% celltalk_gene$grp) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()

######################
## Load Magma genes ##
magma <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/UKB_Breast_cancer.gene_score.txt") %>%
  'colnames<-' ("n") %>%
  separate(n, sep = ":", c("gene", "Mscore")) %>% 
  mutate(magma = 1) %>% dplyr::select(-Mscore)

#table(magma$gene %in% unique(nearbygenes$gene_name)) ## 173 magma genes found out of 1k based on 206 snps
#table(magma$gene %in% unique(geneAnnot.df$gene_name)) ## 952 magma genes found out of 1k in original gtf.
## Again, just the snp doesn't hit those genes. Moving forward.

## Combine findmarkers and cevm
combined.gene.marker <- rbind(cevm.genes, marker.hits) %>% distinct()

## Load lncRNA interaction
load("/drive-pool/data/peter_data/genetic_programming/code/brca/rna.protein.map.rda")
rna.protein.map <- rna.protein.map %>% 'colnames<-' (c("gene1", "gene2")) %>%
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()


## Generate 1k proposals
celltype <- as.character(unique(sct_rna$CellType))
n_proposal <- 1e3
multi_proposal <- mclapply(X = as.list(1:n_proposal), FUN = function(x) {
  generate_proposal() %>% mutate(n = x)
  },
  mc.cores = 10)

multi_proposal <- as.data.frame(do.call(rbind, multi_proposal))
#save(multi_proposal, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi_proposal_071323.rda")
## Objective function
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac") #, "cevm", , "multi.ppi", "findmarkers", "cevm", "go.cc.ppi" #, 


gwas_gp <- function(init.proposal, generations, obj.fun, exclude.celltype = c("ERGpos_Tumor", "ERGneg_Tumor"), khan.method) {
  ## Store result for fitness function
  fitness.res.list <- list() 
  ## Store initial proposal as df
  df <- init.proposal
  n.loci <- length(unique(df$locus))
  ## Set initial proposal as top proposal. This df will be updated to only include the top 1k proposals by avg of avg using current and new proposal
  top.df <- init.proposal
  #################################################################
  ## Loop through proposal for each generation using the obj fun ##
  for(generation in 1:generations) {
    message(paste0("Working on F", generation-1))
    
    ## When we're on the last generation, save the result of the proposal so we can output it. 
    if(generation == max(generations)) {
      last.gen <- df ## Record the last generation
      last.gen$gen <- generation -1
    }
    
    ## Storing results from obj fun for fitness function
    obj.fun.res <- list()

    #############################
    ## CEVM Objective Function ##
    if("cevm" %in% obj.fun) { ## If cevm then do the following
      if(is.null(exclude.celltype)) { 
        cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(cevm = 1)
      } else {
        cevm <- cevm.genes %>% mutate(cevm = 1)
      }
      cevm.obj <- df %>% left_join(x = ., y = cevm, by = c("gene", "celltype")) %>%
        mutate(cevm = replace_na(cevm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cevm = sum(cevm) / length(cevm))
      obj.fun.res[["cevm"]] <- as.data.frame(cevm.obj)
    }
    
    ####################################
    ## FindMarkers Objective Function ##
    if("findmarkers" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(fm = 1)
      } else {
        fm <- marker.hits %>% mutate(fm = 1)
      }
      fm.obj <- df %>% left_join(x = ., y = fm, by = c("gene", "celltype")) %>%
        mutate(fm = replace_na(fm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(fm = sum(fm) / length(fm))
      obj.fun.res[["findmarkers"]] <- as.data.frame(fm.obj)
    }
    
    ########################################
    ## Combined gene marker - CEVM and FM ##
    if("marker.gene" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            marker.gene <- combined.gene.marker %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker.gene = 1)
      } else {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
      }
      marker.gene.obj <- df %>% left_join(x = ., y = marker.gene, by = c("gene", "celltype")) %>%
        mutate(marker.gene = replace_na(marker.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(marker.gene = sum(marker.gene) / length(marker.gene))
      obj.fun.res[["marker.gene"]] <- as.data.frame(marker.gene.obj)
    }
    ##############################
    ## Magma Objective Function ##
    if("magma" %in% obj.fun) {
      magma.obj <- df %>% left_join(x = ., y = magma, by = "gene") %>%
        mutate(magma = replace_na(magma, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(magma = sum(magma) / length(magma))
      obj.fun.res[["magma"]] <- as.data.frame(magma.obj)
    }
    
    if("hi.mut" %in% obj.fun) {
      hi.mut.obj <- df %>% left_join(x = ., y = breast.cancer.gene, by = "gene") %>%
        mutate(cancer.gene = replace_na(cancer.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cancer.gene = sum(cancer.gene) / length(cancer.gene))
      obj.fun.res[["hi.mut"]] <- as.data.frame(hi.mut.obj)
    }
    
    ############################
    ## PPI Objective Function ##
    if(any(c("ppi", "intra.ppi", "inter.ppi", "marker.ppi", "go.cc.ppi") %in% obj.fun)) {
      ppi.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- ppi %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x) 
      
      }, mc.cores = 10)
      ppi.obj <- as.data.frame(do.call(rbind, ppi.obj))
      
      if("intra.ppi" %in% obj.fun) {
        intra.df <-  ppi.obj %>% mutate(intra.commun = case_when(celltype1 == celltype2 ~ 1,
                                                        celltype1 != celltype2 ~ 0)) %>%
          ## Label each cases as 1 or 0 for having same celltype or not, then filter for 1.
          dplyr:::filter(intra.commun == 1) %>%
          group_by(grp = paste(pmax(gene1, gene2), ## Keep only intra combo (no celltalk combo)
                               pmin(gene1, gene2), sep = "_")) %>%
          dplyr::filter(!grp %in% celltalk_gene$grp) %>%
          ungroup() %>%
          dplyr::select(-grp) %>%
          distinct()
        intra.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
          intra.ppi.genes <- intra.df %>% dplyr::filter(n == x)
          if(nrow(intra.ppi.genes) > 0) {
            intra.ppi.genes <- data.frame(gene = unique(c(intra.ppi.genes$gene1, intra.ppi.genes$gene2)),
                                          intra.ppi = 1)
            ## Get specific proposal set 
            intra.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = intra.ppi.genes, by = "gene") %>%
              mutate(intra.ppi = replace_na(intra.ppi, replace = 0)) %>%
              summarise(intra.ppi = sum(intra.ppi) /length(intra.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "intra.ppi")]
          } else {
            intra.res <- data.frame(n = x,
                                    intra.ppi = 0)
          }
        }, mc.cores = 10)
        intra.obj <- as.data.frame(do.call(rbind, intra.obj))
        obj.fun.res[["intra.ppi"]] <- intra.obj
      } ## End of intra ppi
      
      if("ppi" %in% obj.fun) {
        all.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          ppi.df <- ppi.obj %>% dplyr::filter(n == x)
          ppi.genes <- data.frame(gene = unique(c(ppi.df$gene1, ppi.df$gene2)),
                                  ppi = 1)
          ppi.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = ppi.genes, by = "gene") %>%
              mutate(ppi = replace_na(ppi, replace = 0)) %>%
              dplyr::summarise(ppi = sum(ppi) / length(ppi)) %>%
              mutate(n = x) %>% .[, c("n", "ppi")]
        }, mc.cores = 10)
        all.ppi.obj <- as.data.frame(do.call(rbind, all.ppi.obj))
        obj.fun.res[["ppi"]] <- all.ppi.obj
      } ## End of ppi
      
      if("marker.ppi" %in% obj.fun) {
        if(is.null(exclude.celltype)) {
          # fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          # cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          } else {
            marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          }
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() #%>% ## Keep positive hits.
        
        if(nrow(marker.obj) == 0) {
          marker.ppi.obj <- data.frame(n = unique(df$n),
                                       marker.ppi = 0)
        } else {
          marker.ppi.obj <- mclapply(X = as.list(unique(marker.obj$n)), FUN = function(x) {
            marker.df <- marker.obj %>% dplyr::filter(n == x)
            df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            marker.ppi.set <- rbind(df1, df2) %>% mutate(marker.ppi = 1) %>% distinct()
          
            marker.res <- df %>% dplyr::filter(n == x) %>%
                left_join(x = ., y = marker.ppi.set, by = c("gene", "celltype")) %>%
                mutate(marker.ppi = replace_na(marker.ppi, replace = 0)) %>%
                dplyr::summarise(marker.ppi = sum(marker.ppi) / length(marker.ppi)) %>%
                mutate(n = x) %>% .[, c("n", "marker.ppi")]
            }, mc.cores = 10)
          marker.ppi.obj <- as.data.frame(do.call(rbind, marker.ppi.obj))
        }
      
        obj.fun.res[["marker.ppi"]] <- marker.ppi.obj
      } ## End of marker.ppi
      
      if("inter.ppi" %in% obj.fun) {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() %>% ## Keep positive hits.
          dplyr::select(-marker.gene.x, -marker.gene.y) ## Get rid of columns no longer needed
        
        if(nrow(marker.obj) == 0) {
          inter.ppi.obj <- data.frame(n = unique(df$n),
                                      inter.ppi = 0)
        } else {
          ## First identity all source genes in celltalkdb. We will check if the source gene is found in 
          ## gene1 or gene2. If no source gene in either then remove. If source gene is found in both 
          ## Then remove. We will be filtering for rowsums == 1 on source_genesymbol1 and 2.
          inter.obj <- marker.obj %>% left_join(x = ., 
                                                y = celltalkdb[,c("source_genesymbol", "inter.ppi")], 
                                                by = c("gene1"="source_genesymbol"),
                                                relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("source_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("source_genesymbol", "inter.ppi")],
                      by = c("gene2"="source_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>% 
            dplyr::rename("source_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("source_gene1", "source_gene2")], na.rm = TRUE) == 1),] %>%
          
            ## Now trying to find targets the same way we did for source genes
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene1"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene1" = "inter.ppi") %>%
            left_join(x = ., 
                      y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                      by = c("gene2"="target_genesymbol"),
                      relationship = "many-to-many") %>%
            distinct() %>%
            dplyr::rename("target_gene2" = "inter.ppi") %>%
            .[which(rowSums(.[,c("target_gene1", "target_gene2")], na.rm = TRUE) == 1),] %>%
            ## Removing target and source identity column
            dplyr::select(-source_gene1, -source_gene2, -target_gene1, -target_gene2)

          inter.ppi.obj <- mclapply(X = as.list(unique(inter.obj$n)), FUN = function(x) {
            marker.df <- inter.obj %>% dplyr::filter(n == x)
            df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
            inter.ppi.set <- rbind(df1, df2) %>% mutate(inter.ppi = 1) %>% distinct()
          
            inter.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = inter.ppi.set, by = c("gene", "celltype")) %>%
              mutate(inter.ppi = replace_na(inter.ppi, replace = 0)) %>%
              dplyr::summarise(inter.ppi = sum(inter.ppi) / length(inter.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "inter.ppi")]
            }, mc.cores = 10)
          inter.ppi.obj <- as.data.frame(do.call(rbind, inter.ppi.obj)) 
          
          if(nrow(inter.ppi.obj) == 0) {
          inter.ppi.obj <- data.frame(n = unique(df$n),
                                      inter.ppi = 0)
          }
          }
        
        obj.fun.res[["inter.ppi"]] <- inter.ppi.obj
      } ## End of inter.ppi
      
      if("multi.ppi" %in% obj.fun) {
        multi.obj <- ppi.obj %>% dplyr::select(-celltype1,-celltype2) %>% distinct()
        multi.res <- mclapply(X = as.list(unique(multi.obj$n)), FUN = function(x) {
          multi.df <- multi.obj %>% dplyr::filter(n %in% x)
          df1 <- multi.df %>% dplyr::select(gene1, locus1) %>% dplyr::rename("gene"="gene1", "locus"="locus1")
          df2 <- multi.df %>% dplyr::select(gene2, locus2) %>% dplyr::rename("gene"="gene2", "locus"="locus2")
          gene.locus.set <- rbind(df1, df2) %>% mutate(set = paste(gene, locus, sep = "_")) %>%  ## Combine df1 and df2 and create set name
            group_by(set) %>% ## Group by set
            tally() %>% ## ## Count up how many times the set appears
            dplyr::filter(n > 1) %>% nrow() ## Select gene locus combination with more than one interaction
         res <- data.frame(n = x, multi.ppi = gene.locus.set / n.loci)
        }, mc.cores = 10)
        multi.res <- as.data.frame(do.call(rbind, multi.res))
         obj.fun.res[["multi.ppi"]] <- multi.res
      } ## End of multi.ppi
      
      if("go.cc.ppi" %in% obj.fun) {
        go.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          go.ppi.df <- ppi.obj %>% dplyr::filter(n == x) %>% dplyr::select(-celltype1, -celltype2) %>%
            left_join(x = ., ## Add cellular component info for all genes in gene1 (NA means no info on gene)
                      y = map.go.gene[,c("external_gene_name", "name_1006")], 
                      by = c("gene1"="external_gene_name"), 
                      relationship = "many-to-many") %>%
            dplyr::rename("cc1"="name_1006") %>% ## Rename cc column as cc1 to link to gene1
            left_join(x = ., ## Add cc info for gene2
                      y = map.go.gene[,c("external_gene_name", "name_1006")],
                      by = c("gene2"="external_gene_name"),
                      relationship = "many-to-many") %>%
            dplyr::rename("cc2"="name_1006") %>% ## Rename cc column as cc2 to link to gene2
            .[which(.$cc1 == .$cc2),] ## Filter for cases where gene1 and gene2 are in same cellular compartment
          ## Get all genes from go.ppi.df
          go.genes <- data.frame(gene = unique(c(go.ppi.df$gene1, go.ppi.df$gene2)),
                                  go.cc = 1)
          go.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = go.genes, by = "gene") %>%
              mutate(go.cc = replace_na(go.cc, replace = 0)) %>%
              dplyr::summarise(go.cc = sum(go.cc) / length(go.cc)) %>%
              mutate(n = x) %>% .[, c("n", "go.cc")]
        }, mc.cores = 10)
        go.ppi.obj <- as.data.frame(do.call(rbind, go.ppi.obj))
        
        obj.fun.res[["go.cc.ppi"]] <- go.ppi.obj
      }
      
    } ## End of broad ppi umbrella

    #################################
    ## Promoter Objective Function ##
    if("promoter" %in% obj.fun) {
      promoter.obj <- df %>% left_join(x = ., y = promoter.df, by = c("locus", "gene")) %>%
        mutate(promoter = replace_na(promoter, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(promoter = sum(promoter)/length(promoter))
      
      obj.fun.res[["promoter"]] <- promoter.obj
    }
    
    #############################
    ## ATAC Objective Function ##
    ## Marker atac peak 
    if("marker.atac" %in% obj.fun) {
      m.atac.obj <- df %>% left_join(x = ., y = atac.marker, by = c("locus", "celltype")) %>%
        mutate(marker.atac = replace_na(marker.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(marker.atac = sum(marker.atac)/length(marker.atac))
      obj.fun.res[["marker.atac"]] <- m.atac.obj
    }
    ## Common atac peak
    if("common.atac" %in% obj.fun) {
      c.atac.obj <- df %>% left_join(x = ., y = common.atac.hit, by = c("locus", "celltype")) %>%
        mutate(common.atac = replace_na(common.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(common.atac = sum(common.atac)/length(common.atac))
      obj.fun.res[["common.atac"]] <- c.atac.obj
    }
    ########################
    ## lncrna interaction ##
    if("lncrna.ppi" %in% obj.fun) {
      lncrna.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- rna.protein.map %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x)
      }, mc.cores = 10)
      lncrna.obj <- as.data.frame(do.call(rbind, lncrna.obj))
      
      all.lncrna.obj <- mclapply(X = as.list(unique(lncrna.obj$n)), FUN = function(x) {
        lncrna.df <- lncrna.obj %>% dplyr::filter(n == x)
        lncrna.genes <- data.frame(gene = unique(c(lncrna.df$gene1, lncrna.df$gene2)),
                                lncrna = 1)
        lncrna.res <- df %>% dplyr::filter(n == x) %>%
          left_join(x = ., y = lncrna.genes, by = "gene") %>%
          mutate(lncrna = replace_na(lncrna, replace = 0)) %>%
          dplyr::summarise(lncrna = sum(lncrna) / length(lncrna)) %>%
          mutate(n = x) %>% .[, c("n", "lncrna")]
        }, mc.cores = 10)
      all.lncrna.obj <- as.data.frame(do.call(rbind, all.lncrna.obj))
      
      lncrna.res <- data.frame(n = unique(df$n)) %>%
        left_join(x = ., y = all.lncrna.obj, by = "n") %>%
        mutate(lncrna = replace_na(lncrna, replace = 0))
      obj.fun.res[["lncrna.ppi"]] <- lncrna.res
    } ## end of lncrna
    
    
    
    #####################################
    ## Fitness mean objective function ##
    
    for(n in 1:length(obj.fun)) {
      if(n == 1) {
        fitness.obj <- obj.fun.res[[obj.fun[n]]]
      } else {
        add_test <- obj.fun.res[[obj.fun[n]]]
        fitness.obj <- left_join(x = fitness.obj, y = add_test, by = "n")
      }
    }
    fitness.obj[is.na(fitness.obj)] <- 0
    fitness.obj$fitness <- apply(X = fitness.obj %>% dplyr::select(-n), MARGIN = 1, FUN = function(x) {
      mean(x)
    })
    fitness.obj$gen <- generation - 1 
    
    
    ##########
    ## Rank ##
    ## Rank the proposals into 5 groups
    ranked.proposals <- fitness.obj %>% dplyr::select(n, fitness) %>% arrange(., desc(fitness)) %>%
      mutate(quantile = rep(x = 5:1, each = nrow(.)/5))
    ## Prob of quantiles
    group.prob <- c(0.02,0.03,0.05,0.1,0.8)
    names(group.prob) <- 1:max(ranked.proposals$quantile)
    
    #####################
    ## Updating top.df ##

    if(generation-1 == 0) { 
      top.df$gen <- generation - 1
      fitness.df <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
    } else {
      new.fitness <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
      ## Update top rank proposal df with new generation data. Basically, replace proposals that are weaker than the new proposals
      fitness.df <- rbind(fitness.df, new.fitness) %>% arrange(desc(fitness)) %>% .[1:1000,]
      ## Update top df proposal elements based on fitness.df
      keep.list <- fitness.df %>% dplyr::select(n, gen) %>% mutate(keep = 1)
      current.proposal <- df %>% mutate(gen = generation - 1)
      top.df <- rbind(top.df, current.proposal) %>% left_join(x = ., y = keep.list, by = c("n", "gen")) %>%
        dplyr::filter(keep == 1) %>%
        dplyr::select(-keep)
      }
    
    ###################################
    ## Randomly Select 100 Proposals ##
    sel.proposal <- progressive_quantile(group.prob = group.prob, n_proposal = 1e2, proposal = ranked.proposals)
    
    ############
    ## Mating ##
    new.proposal <- mating.pair(sel.proposal = sel.proposal, df = df, khan.method = khan.method, fitness.df = fitness.df, top.df = top.df,
                                generation = generation, n.loci = n.loci)
    new.proposal <- as.data.frame(do.call(rbind,new.proposal)) %>% remove_rownames() %>%
      mutate(n = rep(1:1000, each = n.loci))
    ##############
    ## Mutation ##
    new.proposal <- add.mutations(new.proposal = new.proposal)

    ## Insert khan to the proposal
    rand.kick <- new.proposal %>% rownames_to_column(var = "row") %>% slice_sample(n = 1) %>% .$n
    new.proposal <- new.proposal %>% dplyr::filter(n != rand.kick)

    khan <- fitness.df[1,] ## Which gen and proposal is khan?
    khan.df <- top.df %>% dplyr::filter(n == khan$n, ## Get khan proposals
                                        gen == khan$gen) %>%
      dplyr::select(-gen) %>%
      mutate(n = 1000 + generation)

    new.proposal <- rbind(khan.df, new.proposal)

    ###########################################
    ## Remove one random and add khan inside ##

    df <- new.proposal ## Overwrite multi_proposal with new.proposal

    ###############
    ## Store res ##
    fitness.res.list[[generation]] <- fitness.obj
    

  } ## End loop for generations
  fitness.res.list[["proposal"]] <- last.gen
  fitness.res.list[["top"]] <- top.df
  fitness.res.list[["fitness"]] <-fitness.df
  return(fitness.res.list)
} ## End of wrapper


#ga.run <- gwas_gp(init.proposal = multi_proposal, generations = 5, obj.fun = obj.fun, khan.method = TRUE)
date()
multi.gp <- mclapply(X = as.list(1:3), FUN = function(x) {
  gwas_gp(init.proposal = multi_proposal, generations = 100, obj.fun = obj.fun, khan.method = TRUE)
  }, mc.cores = 3)
date()
save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ctrl_ld_multi.run_121323.rda")

test.run <- multi.gp[[3]]

genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))
```

