---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r libraries}
suppressMessages(c(
  library(tidyverse),
  library(data.table),
  library(motifbreakR, include.only = "snps.from.rsid"),
  library(SNPlocs.Hsapiens.dbSNP155.GRCh38),
  library(BSgenome.Hsapiens.UCSC.hg38),
  library(parallel),
  library(quantsmooth),
  library(pheatmap),
  library(GenomicRanges),
  library(sctransform),
  library(Seurat),
  library(HGNChelper),
  library(ArchR),
  library(dampack)
))
```

Get nearby genes for each credible snp
```{r}
## Load RNA-seq data
rna <- readRDS("/drive-pool/data/peter_data/sc_data/brca/GSE168836/GSE168836_Sobj_Final_Scaled_MetaUpdt_V2.rds")
## sctransform
sct_rna <- SCTransform(rna, vst.flavor = "v2", verbose = TRUE,
                       return.only.var.genes = TRUE)
#save(sct_rna, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/sct_rna.rda")
################################
## Find Nearby Genes from SNP ##
## Create df object using processed gtf.v38.mapped.gene

## Load gtf file used in alignment
gtf <- import("/drive-pool/data/peter_data/genetic_programming/shared_data/refdata-gex-GRCh38-2020-A/genes/genes.gtf")

gtf.df <- gtf %>% as.data.frame() %>% 
  dplyr::filter(type == "gene",
                gene_type %in% c("protein_coding", "lncRNA"))

dup.genes <- gtf.df[which(duplicated(gtf.df$gene_name)),]$gene_name

for(n in dup.genes) {
  dup <- gtf.df %>% dplyr::filter(gene_name %in% n) %>% arrange(., gene_version) ## Arrange version by increasing order
  
  dup.rm <- which(gtf.df$gene_name == dup[1,"gene_name"] & ## Which row needs to be removed
        gtf.df$gene_version == dup[1,"gene_version"])
  
  gtf.df <- gtf.df[-dup.rm,] ## Remove it from gtf.df
}; rm(dup, dup.rm); gc()

table(duplicated(gtf.df$gene_name)) ## No more dups

geneAnnot.df <- gtf.df %>% dplyr::select(seqnames,
                                         start,
                                         end,
                                         strand,
                                         gene_name,
                                         gene_type)


# load("~/gwas/PCa/calc.zscore.all.genes.rda"); rm(calc.avg, calc.tpm, calc.zscore); gc()
# geneAnnot.df <- gtf.v38.mapped.gene %>% dplyr::select(seqnames,
#                                                       start,
#                                                       end,
#                                                       strand,
#                                                       x)
## Get transcription start site based on strand info
geneAnnot.df$tss <- NA
geneAnnot.df[which(geneAnnot.df$strand == "+"), "tss"] <- geneAnnot.df[which(geneAnnot.df$strand == "+"), "start"]
geneAnnot.df[which(geneAnnot.df$strand == "-"), "tss"] <- geneAnnot.df[which(geneAnnot.df$strand == "-"), "end"]
geneAnnot.df$seqnames <- as.character(geneAnnot.df$seqnames)

#save(geneAnnot.df, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")

## Prep data for finding nearest genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda") ## gene annotation
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda") ## Finemap snp
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda") ## Snps in LD with finemap snp

## Simply df to only include relevant column. Also, add column to say what SNPs have LD
snps.df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS, SNP_ID_CURRENT) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS", "SNP_id"="SNP_ID_CURRENT") %>% ## Rename columns
  mutate(seqnames = paste0("chr", seqnames)) %>% ## add chr before chromosome id
  distinct() %>% ## Keep unique observations
  left_join(x = ., ## What lead SNPs have snps in ld
            y = data.frame(SNP_id = unique(ld$LEAD_SNP),
                           LD = 1),
            by = "SNP_id") %>%
  mutate(LD = replace_na(LD, replace = 0))

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.
ldsnps.range <- ld %>% dplyr::group_by(LEAD_SNP) %>%
  dplyr::summarise(min = min(CHR_POS),
                   max = max(CHR_POS))

gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- 10 ## Set the min ngenes a lead snp should have. only needed when elmer.style is false

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)
save(nearbygenes_10xgenomics, file = "/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")

as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  ggplot(data = ., aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Total ngenes") + ylab("Density") +
  ggtitle(paste0("Number of Genes per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

df <- as.data.frame(table(nearbygenes_10xgenomics$snp))


```

Generate findmarker data for breast data
```{r}
load("/drive-pool/data/peter_data/genetic_programming/code/brca/sct_rna.rda") ## Load sctransform data
#sct_rna@active.ident <- sct_rna@meta.data$CellType
#sct_rna$ID_coarse <- as.character(sct_rna@meta.data$CellType)
sct_rna$SampleType = ifelse(grepl("CF", sct_rna@meta.data$orig.ident), "CF", "TM")
Idents(sct_rna) <- sct_rna@meta.data[["CellType"]]
sct_rna <- subset(x = sct_rna, subset = SampleType == "CF") ## Filter data for only CF data

celltype <- unique(as.character(sct_rna@meta.data[["CellType"]]))

marker.list <- list()

for(n in celltype) {
  for(p in celltype) {
    if(n == p) { ## If comparison is same cell type, next
      next
    } else { ## If not the same cell type, find markers
    message(paste0("Working on celltype ", n, " vs ", p))
    vs.group <- paste(n,"vs",p, sep = "_")
      marker <- FindMarkers(sct_rna, assay = "SCT", ident.1 = n, ident.2 = p, test.use = "wilcox",
                        only.pos = TRUE)
      marker <- marker %>% rownames_to_column(var = "gene") %>%
        mutate(celltype1 = n,
               celltype2 = p)
  marker.list[[vs.group]] <- marker
    }
  }
}

marker.list <- as.data.frame(do.call(rbind, marker.list))
save(marker.list, sct_rna, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda"); rm(sct_rna)
table(marker.list$p_val_adj < 0.05)
ggplot(data = marker.list, aes(x = p_val_adj)) +
  geom_density() +
  theme_minimal() +
  xlab("Adjusted P-Value") + ylab("Density") +
  ggtitle("Distribution of Adj. P-Value for FindMarkers")
#ggsave("/drive-pool/data/peter_data/genetic_programming/figure/distrib_pval_findmarkers.png", width = 10, height = 7)
## Based on the plot above, we need to filter the adj pvalue for significance (<= 0.05)
marker.filtered <- marker.list %>% remove_rownames() %>% dplyr::filter(p_val_adj <= 0.05) %>% 
  dplyr::filter(avg_log2FC >= 0.25)

marker.heatmap <- marker.filtered %>% dplyr::select(gene, celltype1, celltype2) %>%
  mutate(hit = 1) %>%
  spread(data = ., key = celltype2, value = hit)
## Lets see how similar are the marker genes for each cell type
celltype <- unique(marker.filtered$celltype1)

ct.jaccard <- data.frame(matrix(data = NA, nrow = length(celltype), ncol = length(celltype))) %>%
  'colnames<-' (celltype) %>%
  'rownames<-' (celltype)

for(n in celltype) {
  ## Get cell type marker genes
    a <- marker.filtered %>% dplyr::filter(celltype1 == n) %>% 
    pull(gene) %>% unique()
  for(p in celltype) {
    b <- marker.filtered %>% dplyr::filter(celltype1 == p) %>% 
    pull(gene) %>% unique()
    ct.jaccard[n,p] <- jaccard(a = a, b = b)
  }
}

pheatmap(ct.jaccard)

marker.hits <- marker.filtered %>% dplyr::select(gene, celltype1) %>% 
  dplyr::rename("celltype"="celltype1") %>%
  distinct() 

## Calculate the n celltype for each marker
marker.plot <- as.data.frame(table(marker.hits$gene))

ggplot(data = marker.plot, aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Number of Celltypes") + ylab("Density") +
  ggtitle("Distribution of Number of Cell Type for Each Marker Gene - FindMarkers") +
  scale_x_continuous(breaks = seq(0, 12, by = 1))

#save(marker.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda")

###########################################################################################
## This is extra code to try to find marker relative to all other celltypes (background) ##
marker.list <- list()

for(n in celltype) {
  message(paste0("Working on celltype ", n))
  marker <- FindMarkers(sct_rna, assay = "SCT", ident.1 = n, ident.2 = NULL, test.use = "wilcox",
                        only.pos = TRUE)
  marker <- marker %>% rownames_to_column(var = "gene") %>%
    mutate(celltype = n)
  marker.list[[n]] <- marker
}

marker.list <- as.data.frame(do.call(rbind, marker.list))
save(marker.list, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda")

marker.filtered <- marker.list %>% remove_rownames() %>% 
  dplyr::filter(p_val_adj <= 0.05,
                avg_log2FC >= 0.25)

marker.hits <- marker.filtered %>% dplyr::select(gene, celltype) %>%
  distinct() 

save(marker.list, marker.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda")

```

Promoter data
```{r}
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")
## Get atac-seq probes and make into granges
genes.granges <- GRanges(seqnames = Rle(nearbygenes$seqnames),
                       range = IRanges(start = nearbygenes$tss),
                       gene = nearbygenes$gene_name)
genes.granges <- unique(genes.granges)

promoter.granges <- promoters(genes.granges, upstream = 1000, downstream = 100)
## Make gwas snps into granges

all.snps <- gwas_finemap[,c("CHR_ID", "CHR_POS", "SNP_ID_CURRENT")] %>%
  dplyr::rename("SNPS"="SNP_ID_CURRENT") %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))
## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = promoter.granges)

promoter.df <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(promoter.granges) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  mutate(promoter = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
promoter.df[which(is.na(promoter.df$LEAD_SNP)), "LEAD_SNP"] <- promoter.df[which(is.na(promoter.df$LEAD_SNP)), "locus"] 

save(promoter.df, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ld_promoter.df.rda")
```

Fusion Gene Objective Function
```{r}
rm(list = ls(all.names = T)); gc()

fusion.gene <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cosmic_fusion.txt")

## Process the data to split genepair column into two separate genes
fusion.gene <- fusion.gene %>% dplyr::select(genepair) %>%
  separate(genepair, sep = " / ", c("protein1", "protein2")) %>%
  mutate(protein1 = gsub(pattern = "_.*", replacement = "", x = protein1),
         protein2 = gsub(pattern = "_.*", replacement = "", x = protein2)) %>% 
  distinct()

fusion.gene <- data.frame(gene = unique(c(fusion.gene$protein1, fusion.gene$protein2)),
                          fusion = 1)

load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_elmer_10xgenomic.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)

table(fusion.gene$gene %in% unique(nearbygenes$gene_name)) ## Only 5 match. Maybe it's not found in the nearbygenes. Maybe it's in the full gtf file.

## Checking that
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")

table(fusion.gene$gene %in% geneAnnot.df$gene_name) ## Yep. 74 out of 75 is present. So it seems like we only have 5 matches for the fusion gene.

save(fusion.gene, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
```

SNP in coding region
```{r}
rm(list = ls(all.names = T)); gc()

## Load gtf file
gtf <- import("/drive-pool/data/peter_data/genetic_programming/shared_data/refdata-gex-GRCh38-2020-A/genes/genes.gtf")

gtf.df <- gtf %>% as.data.frame() %>% 
  dplyr::filter(type %in% c("exon"),
                gene_type %in% c("protein_coding", "lncRNA")); rm(gtf)

## Load snp file
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")

## Convert both snp and gtf to granges object

all.snps <- gwas_finemap[,c("CHR_ID", "CHR_POS", "SNP_ID_CURRENT")] %>%
  dplyr::rename("SNPS"="SNP_ID_CURRENT") %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

gtf <- GRanges(seqnames = Rle(gtf.df$seqnames),
                       range = IRanges(start = gtf.df$start,
                                       end = gtf.df$end),
                       strand = Rle(gtf.df$strand),
                       gene = gtf.df$gene_name,
               exon = gtf.df$exon_number)

## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = gtf)

coding.hits <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(gtf) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  distinct() %>%
  mutate(coding = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
coding.hits[which(is.na(coding.hits$LEAD_SNP)), "LEAD_SNP"] <- coding.hits[which(is.na(coding.hits$LEAD_SNP)), "locus"] 
save(coding.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ld.coding.hits.rda") ## 23 hits in coding (ld now has 234 gene hit)

```

Highly Mutated/Cancer Gene Objective Function
```{r}
cosmic_cancer_consus <- fread(file = "/drive-pool/data/peter_data/genetic_programming/shared_data/Census_allThu Aug 10 16 27 49 2023.tsv") %>%
  .[grep(pattern = "breast", x = .$"Tumour Types(Somatic)")] %>% ## Select genes associated with breast cancer
  dplyr::rename("gene"="Gene Symbol") %>% ## Rename spec. col for easy selection
  dplyr::select(gene) %>% distinct() %>% ## Select spec column 
  mutate(source = "cosmic")

# PMID 27161491: 173 most frequently mutated gene (2,433 primary tumours and 650 normal non-cancerous samples)
pmid_27161491 <- readxl::read_xlsx("/drive-pool/data/peter_data/genetic_programming/shared_data/41467_2016_BFncomms11479_MOESM809_ESM.xlsx",
                       skip = 2) %>% 
  dplyr::rename("gene"="HGNC_symbol") %>%
  dplyr::select(gene) %>% distinct() %>%
  mutate(source = "27161491")

pmid_31287869 <- readxl::read_xlsx("/drive-pool/data/peter_data/genetic_programming/shared_data/ExcelSupp_gkz566.xlsx") %>%
  dplyr::rename("gene"="Gene") %>% 
  dplyr::filter(BRCA != "-") %>%
  dplyr::select(gene) %>%
  mutate(source = "31287869")

breast.cancer.gene <- data.frame(gene = unique(c(cosmic_cancer_consus$gene, pmid_27161491$gene, pmid_31287869$gene)),
                                 cancer.gene = 1)

#save(breast.cancer.gene, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")

## Dennis has concerns that the number of hits in the fg is a little high. Checked to see if fg is over/under-representated using beta distribuion

rm(list = ls(all.names = T)); gc()
library(tidyverse)
library(data.table)
library(BSgenome.Hsapiens.UCSC.hg38)
library(parallel)

load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")

## Load in hg38 genome
hg38 <- GRanges(seqinfo(BSgenome.Hsapiens.UCSC.hg38))
hg38 <- keepStandardChromosomes(hg38, pruning.mode = "coarse")
hg38 <- dropSeqlevels(hg38, "chrM", pruning.mode = "coarse")

## Randomly sample from hg38
chrid <- paste0("chr", gwas_finemap$CHR_ID)

## Randomly sample genomic region using chr id from gwas_finemap (fg)
sample.granges <-unlist(mclapply(X = chrid, FUN = function(x){
  ## Get ranges from granges for specific chr id
  chr.data <- hg38[seqnames(hg38) %in% x] %>% ranges()
  ## Sample from chr.range
  pos <- sample(x = start(chr.data):end(chr.data), size = 1)
},
mc.cores = 10
))

## Create df of chrid and random pos
bg.granges <- data.frame(seqnames = chrid,
                         start = sample.granges) %>%
  mutate(SNP_id = paste(seqnames,start,sep="_")) %>%
  distinct()

## Get nearby genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")
gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type) ## Keep relevant col

## Turn df that needs nearby genes to list
gwas.list <- as.list(as.data.frame(t(bg.granges[, c("seqnames", "start", "SNP_id")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- TRUE

## Get nearby genes function
bg_nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  
  Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
    mutate(distance_tss = tss - as.numeric(x[2])) %>%
    arrange(., distance_tss)
  if(elmer.style == TRUE) {
    if(nrow(Rside) > 4) {
      Rside <- Rside[1:5,]
    }
  } else {
    Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
  }
  if(nrow(Rside) == 0) {
    ## Do nothing
  } else {
    Rside <- Rside %>% mutate(snp = x[3],
                              side = paste0("R", c(1:nrow(.))))
  }
  
  
  Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
    mutate(distance_tss = tss - as.numeric(x[2])) %>%
    arrange(., desc(distance_tss))
  if(elmer.style == TRUE) {
    if(nrow(Lside) > 4) {
      Lside <- Lside[1:5,]
    }
  } else {
    Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
  }
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  if(nrow(Rside) > 0 & nrow(Lside) > 0) {
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) {
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) {
    res <- Rside
  }
  
},
mc.cores = 20
)
## List to df
bg_nearbygenes <- as.data.frame(do.call(rbind, bg_nearbygenes))
## Checking the distribution of ngenes for each bg snp. (Checking sides e.g. L1, L2, L3)
#table(bg_nearbygenes$side)

## Clean up
rm(nearbygenes, chrid, distance_thres, elmer.style, sample.granges, geneAnnot.df, 
   gene.tss, hg38, bg.granges, gwas.list, gwas_catalog, gwas_finemap); gc()

## Load in fg nearbygenes
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_elmer_10xgenomic.rda")
fg_nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics); gc() ## Rename fg obj

## beta distribution test. Is the number of breast cancer genes that we observe between the fg and bg equal or diff?
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")

bg_gene <- unique(bg_nearbygenes$gene_name)
bg_hits <- length(bg_gene[bg_gene %in% breast.cancer.gene$gene])

fg_gene <- unique(fg_nearbygenes$gene_name)
fg_hits <- length(fg_gene[fg_gene %in% breast.cancer.gene$gene])

bg_rbeta <- rbeta(n = 1e5, shape1 = bg_hits, shape2 = length(bg_gene)-bg_hits)
fg_rbeta <- rbeta(n = 1e5, shape1 = fg_hits, shape2 = length(fg_gene)-fg_hits)

### Question 1: what is the fold enrichment
plot(density(fg_rbeta/bg_rbeta), main = "fold enrichment")
### Question 2: is the breast cancer gene enriched relative to background?
plot(density(fg_rbeta))#, xlim = c(0, 0.025), ylim = c(0, 300))
lines(density(bg_rbeta), col='grey')
lines(density(fg_rbeta-bg_rbeta), col='red')

res <- fg_rbeta - bg_rbeta ## Fg - Bg ... to see how many times the Fg is larger than the Bg
CI <- 0.025
quant_diff <- quantile(res, c(CI, 0.5, 1-CI))
quant_diff
pval <- sum(res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
pval

```

Compartment of Genes Objective Function
```{r}
library(GO.db)
xx <- as.list(GOTERM)

x <- sapply(xx, Ontology) ## There are 43,249 GO terms
x <- names(x)[which(x == "CC")] ## 4043 cellular compartment terms

x2 <- xx[names(xx) %in% x]

cc.goterms <- sapply(x2, Term)
cc.goterms <- data.frame(goid = names(cc.goterms),
                         goterm = tolower(cc.goterms)) %>%
  remove_rownames()

ec.cc <- c("cytoplasm", "cytoskeleton", "endoplasmic reticulum", "endosome", "extracellular region",
           "golgi apparatus", "intracellular vesicle", "lysosome", "mitochondrion", "nucleus",
           "peroxisome", "plasma membrane", "ribosome"
           )

selected.cc.go <- cc.goterms %>% dplyr::filter(goterm %in% ec.cc)

## Get the children of selected cc
cc.child <- as.list(GOCCCHILDREN) %>% .[names(.) %in% selected.cc.go$goid]
test1 <- as.list(GOCCOFFSPRING) %>% .[names(.) %in% selected.cc.go$goid]


## Using biomart to extract genes associated with selected GO ID
library(biomaRt)
# listEnsemblArchives() ## Checking available ensembls
# Ensembl 110 Jul 2023 https://jul2023.archive.ensembl.org     110
ensembl <- useEnsembl(biomart = "ensembl", 
                      dataset = "hsapiens_gene_ensembl",
                      host = "https://jul2023.archive.ensembl.org")

## for loop to get all genes associated with selected GO ID
map.go.gene <- list()
for(n in 1:nrow(selected.cc.go)) {
  message(paste0("Working on ", selected.cc.go$goid[n], " : ", selected.cc.go$goterm[n]))
  df <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "go_id", "name_1006"), # "namespace_1003"
              filters = "go", 
              values = selected.cc.go$goid[n], 
              mart = ensembl)
  df <- df %>% dplyr::filter(go_id %in% selected.cc.go$goid[n]) %>% distinct()
  map.go.gene[[selected.cc.go$goterm[n]]] <- df
}
map.go.gene <- as.data.frame(do.call(rbind, map.go.gene))
map.go.gene <- remove_rownames(map.go.gene)

save(map.go.gene, file = "/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
```

CelltalkDB - Ligand receptor ppi from PMID 33147626
```{r}
## Download cvs from review paper https://github.com/LewisLabUCSD/Ligand-Receptor-Pairs PMID 33168968
celltalkdb <- fread("~/Human-2022-Dimitrov-LR-pairs.csv")

# table(unique(nearbygenes$gene_name) %in% unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))
## 74 out of 1844 genes found in celltalkdb. I don't expect a lot of matches b/c this is cell-cell interaction
## But in any case, I'll double check to see if there are any updated gene names in celltalkdb.

check.gene <- checkGeneSymbols(x = unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))
table(check.gene$Approved) ## Only 182 not approved. Checking those. 
false.gene <- check.gene %>% dplyr::filter(Approved == FALSE) ## Falses are due to protein complex
## Are these subunit in the celltalkdb as a separate thing?
"ERBB2" %in% unique(celltalkdb$target_genesymbol) ## It's there. Lets check something else with grep
celltalkdb[grep(pattern = "ERBB2", x = celltalkdb$target_genesymbol),]
## Okay so ERBB2_ERBB4 is a complex and it has a source. So we need to separate the target so we can account for that. 

## Separate complex in source and target column
celltalkdb <- celltalkdb %>% separate_rows(target_genesymbol, sep = "_") %>% 
  separate_rows(source_genesymbol, sep = "_") %>% 
  dplyr::select(source_genesymbol, target_genesymbol) %>%
  distinct()
#table(unique(nearbygenes$gene_name) %in% unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))

## Getting rid of duplicates (reverse pairs)
celltalkdb <- celltalkdb %>% group_by(grp = paste(pmax(target_genesymbol, source_genesymbol), pmin(target_genesymbol, source_genesymbol), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()
  
celltalkdb$inter.ppi <- 1
save(celltalkdb, file = "/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
```

Protein-protein interaction
```{r}
## Load in PPI data from stringdb version 11.5
str.db.link <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/9606.protein.links.full.v11.5.txt.gz") %>%
  as.data.frame() %>%
  dplyr::filter(experiments != 0 | experiments_transferred != 0)

str.db.info <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/9606.protein.info.v11.5.txt.gz") %>%
  as.data.frame() %>%
  .[,1:2] %>% 'colnames<-' (c("string_id", "gene_symbol")) %>%
  distinct()

if(length(unique(str.db.info$string_id)) == nrow(str.db.info)) {
  message("Good, unique string id")
} else {
  message("Beware, there are some duplicated string id")
}

## There are 3 duplicated genes though. It's okay though.
str.db.info$gene_symbol[which(duplicated(str.db.info$gene_symbol))]

## check to see if there are any outdated gene name?
check.gene <- checkGeneSymbols(x = str.db.info$gene_symbol) 
## Taking a look at false genes
false.gene <- check.gene %>% dplyr::filter(Approved == FALSE)

## There are false genes without suggested symbol. Lets see if anything of them stand out. Looking manually
na.gene <- false.gene %>% dplyr::filter(is.na(Suggested.Symbol))

## Manual fixes. The rest are novel genes with ENSG/LOC id
check.gene[which(check.gene$x == "HGNC:9982"), "Suggested.Symbol"] <- "RFX1"
check.gene[which(check.gene$x == "HGNC:9979"), "Suggested.Symbol"] <- "RFPL2"

## Apply fixes to genes with suggested symbol
suggested.gene <- false.gene %>% dplyr::filter(!is.na(Suggested.Symbol))
## There are some with multiple suggested.symbol. If you grep with "///"
## Using manually curated txt file to fix those
suggested.fix <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/multigene.suggested.fix.txt")

for(n in suggested.fix$x) {
  check.gene[which(check.gene$x == n), "Suggested.Symbol"] <- suggested.fix[which(suggested.fix$x == n), "Fixed.Suggested"]
}
## Sanity check. good all multiple cases are fixed
check.gene[grep(pattern = "///", x = check.gene$Suggested.Symbol),] 

## Removing the cases with the multiple gene suggestion "///" so we can apply the other fixes 
suggested.gene <- suggested.gene[-grep(pattern = "///", x = suggested.gene$Suggested.Symbol),]
## Apply fix to updated gene name
for(n in suggested.gene$x) {
  check.gene[which(check.gene$x == n), "Suggested.Symbol"] <- suggested.gene[which(suggested.gene$x == n), "Suggested.Symbol"]
}

## Finally, genes without any updates are just updated on Suggested.Symbol
check.gene[which(is.na(check.gene$Suggested.Symbol)), "Suggested.Symbol"] <- check.gene[which(is.na(check.gene$Suggested.Symbol)), "x"]

str.db.info <- str.db.info %>% left_join(x = ., y = check.gene[,c("x", "Suggested.Symbol")], by = c("gene_symbol"="x")) %>%
  distinct()

rm(false.gene, na.gene, suggested.gene, suggested.fix); gc()

## Load nearbygene info
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics %>%
  dplyr::select(snp, gene_name, gene_type) %>%
  left_join(x = ., y = str.db.info, by = c("gene_name"="Suggested.Symbol"))
rm(nearbygenes_10xgenomics)

map.genes <- nearbygenes

## Checking the number of unmap genes by gene_type
table(is.na(nearbygenes$string_id), nearbygenes$gene_type) 
## Thats the best we can do for now.

#save(str.db.info, str.db.link, map.genes, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
```




Genetic Programming
```{r}
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_elmer_10xgenomic.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")  ## gwas catalog and finemap
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda") ## marker genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda"); rm(marker.list); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/promoter.df.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cevm.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/atac.marker.rda")
atac.marker <- atac.marker %>% dplyr::rename("marker.atac"="atac")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
## Merge fusion.gene with breast.cancer.gene
fusion.gene <- fusion.gene %>% dplyr::rename("cancer.gene"="fusion") ## Rename colname for rbind
breast.cancer.gene <- rbind(breast.cancer.gene, fusion.gene) ## rbind together
breast.cancer.gene <- distinct(breast.cancer.gene); rm(fusion.gene) ## Keep unique observation
#load("/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
load("/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
celltalkdb$inter.ppi <- 1 ## Add 
load("/drive-pool/data/peter_data/genetic_programming/code/brca/common_atac_peak.rda")
common.atac.hit <- common.atac.hit %>% dplyr::select(locus, GroupReplicate) %>%
  dplyr::rename("celltype"="GroupReplicate") %>%
  mutate(common.atac = 1) %>%
  distinct()


loci2gene <- nearbygenes %>% dplyr::select(snp, gene_name) %>% 
  remove_rownames() %>%
  dplyr::rename("cytoband"="snp") %>%
  distinct()

loci <- unique(loci2gene$cytoband) 

###########################################
## Gene Ontology Cellular Component Prep ##
go_gene <- map.go.gene %>% dplyr::filter(external_gene_name %in% loci2gene$gene_name)
## There is 1844 unique genes in loci2gene, but only 741 mapped with map.go.gene. Why? Naming issue? Lets check
# check.gene <- checkGeneSymbols(unique(map.go.gene$external_gene_name)) %>%
#   dplyr::filter(x != "")
# updated.gene <- check.gene %>% dplyr::filter(Approved == FALSE)
## It's just not mapped to it. Tried updating the gene symbol but no additional matches
#table(go_gene$external_gene_name %in% unique(geneAnnot.df$gene_name))
## Check the original gtf file and all genes from go_gene is present.
## Just the snp doesn't hit those genes. Moving forward.

#############################################
## Highly Mutated/Cancer Driver Genes Prep ##
# breast.cancer.gene

# table(breast.cancer.gene$gene %in% unique(loci2gene$gene_name)) ## Only 20 genes map to loci2gene why?
## Checking to see if gene has updated symbol
# check.gene <- checkGeneSymbols(unique(breast.cancer.gene$gene))
# table(check.gene$Approved == FALSE) ## 185 have the most uptodate gene symbol...
## Lets check loci2gene
# check.gene <- checkGeneSymbols(unique(loci2gene$gene_name)) %>% dplyr::filter(Approved == FALSE) 
## Nope. Most genes with FALSE for approved are noncoding rna. and the very few with updates, they aren't found in breast.cancer.gene.
## So it's really only 20 genes for highly mutated genes/ cancer genes based on these snps
## Check the original gtf file and 186 of 190 genes from breast cancer gene is present.
## Again, just the snp doesn't hit those genes. Moving forward.

############
## PPI df ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
## Update the link data to have gene symbol
str.db.link <- str.db.link %>% dplyr::select(protein1, protein2, experiments, 
                                             experiments_transferred, combined_score) %>%
  left_join(x = ., y = str.db.info, by = c("protein1"="string_id")) %>%
  dplyr::rename("gene1"="gene_symbol") %>%
  left_join(x = ., y = str.db.info, by = c("protein2"="string_id")) %>%
  dplyr::rename("gene2"="gene_symbol") %>%
  .[,c("protein1", "protein2", "gene1", "gene2", "experiments", "experiments_transferred", "combined_score")]

ppi <- str.db.link %>% dplyr::select(gene1, gene2) %>%
  dplyr::filter(gene1 %in% map.genes$gene_name, 
                gene2 %in% map.genes$gene_name) %>% ## Filter for specific genes found in gwas 200kb
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct(); rm(str.db.info, map.genes, str.db.link); gc()


## Prepare intra.cellular ppi
## Remove gene combo found in celltalkdb
celltalk_gene <- celltalkdb %>% dplyr::select(source_genesymbol, target_genesymbol) %>%
  dplyr::rename("gene1"="source_genesymbol", "gene2"="target_genesymbol") %>%
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_"))
  
intra.ppi.gene <- ppi %>% 
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(!grp %in% celltalk_gene$grp) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()

######################
## Load Magma genes ##
magma <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/UKB_Breast_cancer.gene_score.txt") %>%
  'colnames<-' ("n") %>%
  separate(n, sep = ":", c("gene", "Mscore")) %>% 
  mutate(magma = 1) %>% dplyr::select(-Mscore)

#table(magma$gene %in% unique(nearbygenes$gene_name)) ## 173 magma genes found out of 1k based on 206 snps
#table(magma$gene %in% unique(geneAnnot.df$gene_name)) ## 952 magma genes found out of 1k in original gtf.
## Again, just the snp doesn't hit those genes. Moving forward.

## Combine findmarkers and cevm
combined.gene.marker <- rbind(cevm.genes, marker.hits) %>% distinct()

## Load lncRNA interaction
load("/drive-pool/data/peter_data/genetic_programming/code/brca/rna.protein.map.rda")
rna.protein.map <- rna.protein.map %>% 'colnames<-' (c("gene1", "gene2")) %>%
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()


## Generate 1k proposals
celltype <- as.character(unique(sct_rna$CellType))
n_proposal <- 1e3
multi_proposal <- mclapply(X = as.list(1:n_proposal), FUN = function(x) {
  generate_proposal() %>% mutate(n = x)
  },
  mc.cores = 10)

multi_proposal <- as.data.frame(do.call(rbind, multi_proposal))
#save(multi_proposal, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi_proposal_071323.rda")
## Objective function
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter", "marker.atac", "common.atac") #, "cevm", , "multi.ppi", "findmarkers", "cevm", "go.cc.ppi"


gwas_gp <- function(init.proposal, generations, obj.fun, exclude.celltype = c("ERGpos_Tumor", "ERGneg_Tumor"), khan.method) {
  ## Store result for fitness function
  fitness.res.list <- list() 
  ## Store initial proposal as df
  df <- init.proposal
  n.loci <- length(unique(df$locus))
  ## Set initial proposal as top proposal. This df will be updated to only include the top 1k proposals by avg of avg using current and new proposal
  top.df <- init.proposal
  #################################################################
  ## Loop through proposal for each generation using the obj fun ##
  for(generation in 1:generations) {
    message(paste0("Working on F", generation-1))
    
    ## When we're on the last generation, save the result of the proposal so we can output it. 
    if(generation == max(generations)) {
      last.gen <- df ## Record the last generation
      last.gen$gen <- generation -1
    }
    
    ## Storing results from obj fun for fitness function
    obj.fun.res <- list()

    #############################
    ## CEVM Objective Function ##
    if("cevm" %in% obj.fun) { ## If cevm then do the following
      if(is.null(exclude.celltype)) { 
        cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(cevm = 1)
      } else {
        cevm <- cevm.genes %>% mutate(cevm = 1)
      }
      cevm.obj <- df %>% left_join(x = ., y = cevm, by = c("gene", "celltype")) %>%
        mutate(cevm = replace_na(cevm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cevm = sum(cevm) / length(cevm))
      obj.fun.res[["cevm"]] <- as.data.frame(cevm.obj)
    }
    
    ####################################
    ## FindMarkers Objective Function ##
    if("findmarkers" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(fm = 1)
      } else {
        fm <- marker.hits %>% mutate(fm = 1)
      }
      fm.obj <- df %>% left_join(x = ., y = fm, by = c("gene", "celltype")) %>%
        mutate(fm = replace_na(fm, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(fm = sum(fm) / length(fm))
      obj.fun.res[["findmarkers"]] <- as.data.frame(fm.obj)
    }
    
    ########################################
    ## Combined gene marker - CEVM and FM ##
    if("marker.gene" %in% obj.fun) {
      if(is.null(exclude.celltype)) {
            marker.gene <- combined.gene.marker %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker.gene = 1)
      } else {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
      }
      marker.gene.obj <- df %>% left_join(x = ., y = marker.gene, by = c("gene", "celltype")) %>%
        mutate(marker.gene = replace_na(marker.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(marker.gene = sum(marker.gene) / length(marker.gene))
      obj.fun.res[["marker.gene"]] <- as.data.frame(marker.gene.obj)
    }
    ##############################
    ## Magma Objective Function ##
    if("magma" %in% obj.fun) {
      magma.obj <- df %>% left_join(x = ., y = magma, by = "gene") %>%
        mutate(magma = replace_na(magma, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(magma = sum(magma) / length(magma))
      obj.fun.res[["magma"]] <- as.data.frame(magma.obj)
    }
    
    if("hi.mut" %in% obj.fun) {
      hi.mut.obj <- df %>% left_join(x = ., y = breast.cancer.gene, by = "gene") %>%
        mutate(cancer.gene = replace_na(cancer.gene, replace = 0)) %>% 
        dplyr::group_by(n) %>% dplyr::summarise(cancer.gene = sum(cancer.gene) / length(cancer.gene))
      obj.fun.res[["hi.mut"]] <- as.data.frame(hi.mut.obj)
    }
    
    ############################
    ## PPI Objective Function ##
    if(any(c("ppi", "intra.ppi", "inter.ppi", "marker.ppi", "go.cc.ppi") %in% obj.fun)) {
      ppi.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- ppi %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x) 
      
      }, mc.cores = 10)
      ppi.obj <- as.data.frame(do.call(rbind, ppi.obj))
      
      if("intra.ppi" %in% obj.fun) {
        intra.df <-  ppi.obj %>% mutate(intra.commun = case_when(celltype1 == celltype2 ~ 1,
                                                        celltype1 != celltype2 ~ 0)) %>%
          ## Label each cases as 1 or 0 for having same celltype or not, then filter for 1.
          dplyr:::filter(intra.commun == 1) %>%
          group_by(grp = paste(pmax(gene1, gene2), ## Keep only intra combo (no celltalk combo)
                               pmin(gene1, gene2), sep = "_")) %>%
          dplyr::filter(!grp %in% celltalk_gene$grp) %>%
          ungroup() %>%
          dplyr::select(-grp) %>%
          distinct()
        intra.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
          intra.ppi.genes <- intra.df %>% dplyr::filter(n == x)
          if(nrow(intra.ppi.genes) > 0) {
            intra.ppi.genes <- data.frame(gene = unique(c(intra.ppi.genes$gene1, intra.ppi.genes$gene2)),
                                          intra.ppi = 1)
            ## Get specific proposal set 
            intra.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = intra.ppi.genes, by = "gene") %>%
              mutate(intra.ppi = replace_na(intra.ppi, replace = 0)) %>%
              summarise(intra.ppi = sum(intra.ppi) /length(intra.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "intra.ppi")]
          } else {
            intra.res <- data.frame(n = x,
                                    intra.ppi = 0)
          }
        }, mc.cores = 10)
        intra.obj <- as.data.frame(do.call(rbind, intra.obj))
        obj.fun.res[["intra.ppi"]] <- intra.obj
      } ## End of intra ppi
      
      if("ppi" %in% obj.fun) {
        all.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          ppi.df <- ppi.obj %>% dplyr::filter(n == x)
          ppi.genes <- data.frame(gene = unique(c(ppi.df$gene1, ppi.df$gene2)),
                                  ppi = 1)
          ppi.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = ppi.genes, by = "gene") %>%
              mutate(ppi = replace_na(ppi, replace = 0)) %>%
              dplyr::summarise(ppi = sum(ppi) / length(ppi)) %>%
              mutate(n = x) %>% .[, c("n", "ppi")]
        }, mc.cores = 10)
        all.ppi.obj <- as.data.frame(do.call(rbind, all.ppi.obj))
        obj.fun.res[["ppi"]] <- all.ppi.obj
      } ## End of ppi
      
      if("marker.ppi" %in% obj.fun) {
        if(is.null(exclude.celltype)) {
          # fm <- marker.hits %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          # cevm <- cevm.genes %>% dplyr::filter(!celltype %in% exclude.celltype) %>% mutate(marker = 1)
          marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          } else {
            marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
          }
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() #%>% ## Keep positive hits.
        
        marker.ppi.obj <- mclapply(X = as.list(unique(marker.obj$n)), FUN = function(x) {
          marker.df <- marker.obj %>% dplyr::filter(n == x)
          df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          marker.ppi.set <- rbind(df1, df2) %>% mutate(marker.ppi = 1) %>% distinct()
          
          marker.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = marker.ppi.set, by = c("gene", "celltype")) %>%
              mutate(marker.ppi = replace_na(marker.ppi, replace = 0)) %>%
              dplyr::summarise(marker.ppi = sum(marker.ppi) / length(marker.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "marker.ppi")]
        }, mc.cores = 10)
        marker.ppi.obj <- as.data.frame(do.call(rbind, marker.ppi.obj))
      
        obj.fun.res[["marker.ppi"]] <- marker.ppi.obj
      } ## End of marker.ppi
      
      if("inter.ppi" %in% obj.fun) {
        marker.gene <- combined.gene.marker %>% mutate(marker.gene = 1)
        all.markers <- marker.gene %>% distinct() #rbind(fm, cevm) %>% distinct()
        
        marker.obj <- ppi.obj %>% left_join(x = ., y = all.markers, by = c("gene1"="gene", "celltype1"="celltype")) %>%
          left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
          na.omit() %>% ## Keep positive hits.
          dplyr::select(-marker.gene.x, -marker.gene.y) ## Get rid of columns no longer needed
        
        ## First identity all source genes in celltalkdb. We will check if the source gene is found in 
        ## gene1 or gene2. If no source gene in either then remove. If source gene is found in both 
        ## Then remove. We will be filtering for rowsums == 1 on source_genesymbol1 and 2.
        inter.obj <- marker.obj %>% left_join(x = ., 
                                              y = celltalkdb[,c("source_genesymbol", "inter.ppi")], 
                                              by = c("gene1"="source_genesymbol"),
                                              relationship = "many-to-many") %>%
          distinct() %>%
          dplyr::rename("source_gene1" = "inter.ppi") %>%
          left_join(x = ., 
                    y = celltalkdb[,c("source_genesymbol", "inter.ppi")],
                    by = c("gene2"="source_genesymbol"),
                    relationship = "many-to-many") %>%
          distinct() %>% 
          dplyr::rename("source_gene2" = "inter.ppi") %>%
          .[which(rowSums(.[,c("source_gene1", "source_gene2")], na.rm = TRUE) == 1),] %>%
          
          ## Now trying to find targets the same way we did for source genes
          left_join(x = ., 
                    y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                    by = c("gene1"="target_genesymbol"),
                    relationship = "many-to-many") %>%
          distinct() %>%
          dplyr::rename("target_gene1" = "inter.ppi") %>%
          left_join(x = ., 
                    y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                    by = c("gene2"="target_genesymbol"),
                    relationship = "many-to-many") %>%
          distinct() %>%
          dplyr::rename("target_gene2" = "inter.ppi") %>%
          .[which(rowSums(.[,c("target_gene1", "target_gene2")], na.rm = TRUE) == 1),] %>%
          ## Removing target and source identity column
          dplyr::select(-source_gene1, -source_gene2, -target_gene1, -target_gene2)

        inter.ppi.obj <- mclapply(X = as.list(unique(inter.obj$n)), FUN = function(x) {
          marker.df <- inter.obj %>% dplyr::filter(n == x)
          df1 <- marker.df %>% dplyr::select(gene1, celltype1) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          df2 <- marker.df %>% dplyr::select(gene2, celltype2) %>% 'colnames<-' (c("gene", "celltype")) %>% distinct()
          inter.ppi.set <- rbind(df1, df2) %>% mutate(inter.ppi = 1) %>% distinct()
          
          inter.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = inter.ppi.set, by = c("gene", "celltype")) %>%
              mutate(inter.ppi = replace_na(inter.ppi, replace = 0)) %>%
              dplyr::summarise(inter.ppi = sum(inter.ppi) / length(inter.ppi)) %>%
              mutate(n = x) %>% .[, c("n", "inter.ppi")]
        }, mc.cores = 10)
        inter.ppi.obj <- as.data.frame(do.call(rbind, inter.ppi.obj))
      
        obj.fun.res[["inter.ppi"]] <- inter.ppi.obj
      } ## End of inter.ppi
      
      if("multi.ppi" %in% obj.fun) {
        multi.obj <- ppi.obj %>% dplyr::select(-celltype1,-celltype2) %>% distinct()
        multi.res <- mclapply(X = as.list(unique(multi.obj$n)), FUN = function(x) {
          multi.df <- multi.obj %>% dplyr::filter(n %in% x)
          df1 <- multi.df %>% dplyr::select(gene1, locus1) %>% dplyr::rename("gene"="gene1", "locus"="locus1")
          df2 <- multi.df %>% dplyr::select(gene2, locus2) %>% dplyr::rename("gene"="gene2", "locus"="locus2")
          gene.locus.set <- rbind(df1, df2) %>% mutate(set = paste(gene, locus, sep = "_")) %>%  ## Combine df1 and df2 and create set name
            group_by(set) %>% ## Group by set
            tally() %>% ## ## Count up how many times the set appears
            dplyr::filter(n > 1) %>% nrow() ## Select gene locus combination with more than one interaction
         res <- data.frame(n = x, multi.ppi = gene.locus.set / n.loci)
        }, mc.cores = 10)
        multi.res <- as.data.frame(do.call(rbind, multi.res))
         obj.fun.res[["multi.ppi"]] <- multi.res
      } ## End of multi.ppi
      
      if("go.cc.ppi" %in% obj.fun) {
        go.ppi.obj <- mclapply(X = as.list(unique(ppi.obj$n)), FUN = function(x) {
          go.ppi.df <- ppi.obj %>% dplyr::filter(n == x) %>% dplyr::select(-celltype1, -celltype2) %>%
            left_join(x = ., ## Add cellular component info for all genes in gene1 (NA means no info on gene)
                      y = map.go.gene[,c("external_gene_name", "name_1006")], 
                      by = c("gene1"="external_gene_name"), 
                      relationship = "many-to-many") %>%
            dplyr::rename("cc1"="name_1006") %>% ## Rename cc column as cc1 to link to gene1
            left_join(x = ., ## Add cc info for gene2
                      y = map.go.gene[,c("external_gene_name", "name_1006")],
                      by = c("gene2"="external_gene_name"),
                      relationship = "many-to-many") %>%
            dplyr::rename("cc2"="name_1006") %>% ## Rename cc column as cc2 to link to gene2
            .[which(.$cc1 == .$cc2),] ## Filter for cases where gene1 and gene2 are in same cellular compartment
          ## Get all genes from go.ppi.df
          go.genes <- data.frame(gene = unique(c(go.ppi.df$gene1, go.ppi.df$gene2)),
                                  go.cc = 1)
          go.res <- df %>% dplyr::filter(n == x) %>%
              left_join(x = ., y = go.genes, by = "gene") %>%
              mutate(go.cc = replace_na(go.cc, replace = 0)) %>%
              dplyr::summarise(go.cc = sum(go.cc) / length(go.cc)) %>%
              mutate(n = x) %>% .[, c("n", "go.cc")]
        }, mc.cores = 10)
        go.ppi.obj <- as.data.frame(do.call(rbind, go.ppi.obj))
        
        obj.fun.res[["go.cc.ppi"]] <- go.ppi.obj
      }
      
    } ## End of broad ppi umbrella

    #################################
    ## Promoter Objective Function ##
    if("promoter" %in% obj.fun) {
      promoter.obj <- df %>% left_join(x = ., y = promoter.df, by = c("locus", "gene")) %>%
        mutate(promoter = replace_na(promoter, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(promoter = sum(promoter)/length(promoter))
      obj.fun.res[["promoter"]] <- promoter.obj
    }
    
    #############################
    ## ATAC Objective Function ##
    ## Marker atac peak 
    if("marker.atac" %in% obj.fun) {
      m.atac.obj <- df %>% left_join(x = ., y = atac.marker, by = c("locus", "celltype")) %>%
        mutate(marker.atac = replace_na(marker.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(marker.atac = sum(marker.atac)/length(marker.atac))
      obj.fun.res[["marker.atac"]] <- m.atac.obj
    }
    ## Common atac peak
    if("common.atac" %in% obj.fun) {
      c.atac.obj <- df %>% left_join(x = ., y = common.atac.hit, by = c("locus", "celltype")) %>%
        mutate(common.atac = replace_na(common.atac, replace = 0)) %>%
        dplyr::group_by(n) %>% dplyr::summarise(common.atac = sum(common.atac)/length(common.atac))
      obj.fun.res[["common.atac"]] <- c.atac.obj
    }
    ########################
    ## lncrna interaction ##
    if("lncrna.ppi" %in% obj.fun) {
      lncrna.obj <- mclapply(X = as.list(unique(df$n)), FUN = function(x) {
        ## Get info on proposal
        proposal.set <- df %>% dplyr::filter(n == x) %>% dplyr::select(-n)
        ## Match proposal elements with ppi
        match.set <- rna.protein.map %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
                                       relationship = "many-to-many") %>%
          dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
          left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
                    relationship = "many-to-many") %>%
          dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
          na.omit() %>%
          mutate(n = x)
      }, mc.cores = 10)
      lncrna.obj <- as.data.frame(do.call(rbind, lncrna.obj))
      
      all.lncrna.obj <- mclapply(X = as.list(unique(lncrna.obj$n)), FUN = function(x) {
        lncrna.df <- lncrna.obj %>% dplyr::filter(n == x)
        lncrna.genes <- data.frame(gene = unique(c(lncrna.df$gene1, lncrna.df$gene2)),
                                lncrna = 1)
        lncrna.res <- df %>% dplyr::filter(n == x) %>%
          left_join(x = ., y = lncrna.genes, by = "gene") %>%
          mutate(lncrna = replace_na(lncrna, replace = 0)) %>%
          dplyr::summarise(lncrna = sum(lncrna) / length(lncrna)) %>%
          mutate(n = x) %>% .[, c("n", "lncrna")]
        }, mc.cores = 10)
      all.lncrna.obj <- as.data.frame(do.call(rbind, all.lncrna.obj))
      
      lncrna.res <- data.frame(n = unique(df$n)) %>%
        left_join(x = ., y = all.lncrna.obj, by = "n") %>%
        mutate(lncrna = replace_na(lncrna, replace = 0))
      obj.fun.res[["lncrna.ppi"]] <- lncrna.res
    } ## end of lncrna
    
    
    
    #####################################
    ## Fitness mean objective function ##
    
    for(n in 1:length(obj.fun)) {
      if(n == 1) {
        fitness.obj <- obj.fun.res[[obj.fun[n]]]
      } else {
        add_test <- obj.fun.res[[obj.fun[n]]]
        fitness.obj <- left_join(x = fitness.obj, y = add_test, by = "n")
      }
    }
    fitness.obj[is.na(fitness.obj)] <- 0
    fitness.obj$fitness <- apply(X = fitness.obj %>% dplyr::select(-n), MARGIN = 1, FUN = function(x) {
      mean(x)
    })
    fitness.obj$gen <- generation - 1 
    
    
    ##########
    ## Rank ##
    ## Rank the proposals into 5 groups
    ranked.proposals <- fitness.obj %>% dplyr::select(n, fitness) %>% arrange(., desc(fitness)) %>%
      mutate(quantile = rep(x = 5:1, each = nrow(.)/5))
    ## Prob of quantiles
    group.prob <- c(0.02,0.03,0.05,0.1,0.8)
    names(group.prob) <- 1:max(ranked.proposals$quantile)
    
    #####################
    ## Updating top.df ##

    if(generation-1 == 0) { 
      top.df$gen <- generation - 1
      fitness.df <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
    } else {
      new.fitness <- ranked.proposals %>% dplyr::select(-quantile) %>% mutate(gen = generation - 1)
      ## Update top rank proposal df with new generation data. Basically, replace proposals that are weaker than the new proposals
      fitness.df <- rbind(fitness.df, new.fitness) %>% arrange(desc(fitness)) %>% .[1:1000,]
      ## Update top df proposal elements based on fitness.df
      keep.list <- fitness.df %>% dplyr::select(n, gen) %>% mutate(keep = 1)
      current.proposal <- df %>% mutate(gen = generation - 1)
      top.df <- rbind(top.df, current.proposal) %>% left_join(x = ., y = keep.list, by = c("n", "gen")) %>%
        dplyr::filter(keep == 1) %>%
        dplyr::select(-keep)
      }
    
    ###################################
    ## Randomly Select 100 Proposals ##
    sel.proposal <- progressive_quantile(group.prob = group.prob, n_proposal = 1e2, proposal = ranked.proposals)
    
    ############
    ## Mating ##
    new.proposal <- mating.pair(sel.proposal = sel.proposal, df = df, khan.method = khan.method, fitness.df = fitness.df, top.df = top.df,
                                generation = generation, n.loci = n.loci)
    new.proposal <- as.data.frame(do.call(rbind,new.proposal)) %>% remove_rownames() %>%
      mutate(n = rep(1:1000, each = n.loci))
    ##############
    ## Mutation ##
    new.proposal <- add.mutations(new.proposal = new.proposal)

    ## Insert khan to the proposal
    rand.kick <- new.proposal %>% rownames_to_column(var = "row") %>% slice_sample(n = 1) %>% .$n
    new.proposal <- new.proposal %>% dplyr::filter(n != rand.kick)

    khan <- fitness.df[1,] ## Which gen and proposal is khan?
    khan.df <- top.df %>% dplyr::filter(n == khan$n, ## Get khan proposals
                                        gen == khan$gen) %>%
      dplyr::select(-gen) %>%
      mutate(n = 1000 + generation)

    new.proposal <- rbind(khan.df, new.proposal)

    ###########################################
    ## Remove one random and add khan inside ##

    df <- new.proposal ## Overwrite multi_proposal with new.proposal

    ###############
    ## Store res ##
    fitness.res.list[[generation]] <- fitness.obj
    

  } ## End loop for generations
  fitness.res.list[["proposal"]] <- last.gen
  fitness.res.list[["top"]] <- top.df
  fitness.res.list[["fitness"]] <-fitness.df
  return(fitness.res.list)
} ## End of wrapper


ga.run <- gwas_gp(init.proposal = multi_proposal, generations = 150, obj.fun = obj.fun, khan.method = TRUE)
save(ga.run, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ga.run_breast.rda")

date()
multi.gp <- mclapply(X = as.list(1:3), FUN = function(x) {
  gwas_gp(init.proposal = multi_proposal, generations = 150, obj.fun = obj.fun, khan.method = TRUE)
  }, mc.cores = 3)
date()
save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_090523.rda")

###################
## Post analysis ##
###################
load("/drive-pool/data/peter_data/genetic_programming/code/brca/test.run_markerfix.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ga.run_breast.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_nofusion.rda")

test.run <- multi.gp[[3]]
#test.run <- ga.run
top.proposal <- test.run[["proposal"]]

genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))

#write.table(x = result, file = "~/summ.confidcall.txt", quote = FALSE, row.names = FALSE)

confid.locus.plot <- ggplot(result, aes(x = locus, y = Freq.y)) +
  geom_point() +
  xlab("SNP") + ylab("Frequency") + 
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
confid.locus.plot

confid.ct.plot <- ggplot(result, aes(x = celltype, y = Freq.y)) +
  geom_point(position=position_dodge(width = .5)) +
  xlab("Celltype") + ylab("Frequency") + 
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
confid.ct.plot

## chi sq test with celltype confidence 
top.proposal <- test.run[["top"]]
expected.rate <- 100/length(celltype) / 100 ## Get proportion of celltype under null hypo (even distribution)
expected <- data.frame(type = "expected",
                       celltype = rep(x = celltype, times = expected.rate * 1000))
n_proposal <- 1e3

chi.sq.res <- as.data.frame(matrix(data = NA, nrow = length(locus), ncol = 2)) %>% 'colnames<-' (c("locus", "pval"))

locus <- unique(top.proposal$locus)
counter <- 1

for(n in locus) {
  spec.loci <- top.proposal[which(top.proposal$locus == n),] %>%
    mutate(type = "observed") %>% dplyr::select(type, celltype)
  ## Combine observe and expected loci
  o.e.loci <- rbind(spec.loci, expected)
  ## chi sq test
  res <- chisq.test(table(o.e.loci$type, o.e.loci$celltype))
  
  chi.sq.res[counter, "locus"] <- n
  chi.sq.res[counter, "pval"] <- res$p.value
  ## Add to counter
  counter <- counter + 1
}

chi.sq.res$adj.pval <- p.adjust(chi.sq.res$pval, "BH")
chi.sq.res$log10adjp <- -log10(chi.sq.res$adj.pval)

ggplot(data = chi.sq.res, aes(x = log10adjp)) +
  geom_density()

ggplot(result, aes(x = celltype, y = Freq.y)) + geom_beeswarm()
# ngenesbyrsid <- as.data.frame(table(nearbygenes$snp))
# 
# gene.res <- result[,1:3] %>% left_join(x = ., y = ngenesbyrsid, by = c("locus"="Var1")) %>%
#   left_join(x = ., y = nearbygenes, by = c("locus"="snp", "gene"="gene_name"))
# 
# 
# ppi.top.proposal <- mclapply(X = as.list(unique(top.proposal$n)), FUN = function(x) {
#         ## Get info on proposal
#         proposal.set <- top.proposal %>% dplyr::filter(n == x) %>% dplyr::select(-n)
#         ## Match proposal elements with ppi
#         match.set <- ppi %>% left_join(x = ., y = proposal.set, by = c("gene1"="gene"),
#                                        relationship = "many-to-many") %>%
#           dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
#           left_join(x = ., y = proposal.set, by = c("gene2"="gene"),
#                     relationship = "many-to-many") %>%
#           dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
#           na.omit() %>%
#           mutate(n = x) 
#       
#       }, mc.cores = 10)
# ppi.top.proposal <- as.data.frame(do.call(rbind, ppi.top.proposal))

fitness.allgen <- as.data.frame(do.call(rbind, test.run[1:150]))

gp.plotdata <- fitness.allgen %>% gather(data = ., key = "method", value = "fraction", -n, -gen)
unique(gp.plotdata$method)
gp.plotdata$method <- factor(gp.plotdata$method, levels = c("marker.gene", "magma", "cancer.gene", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna", "promoter", "marker.atac", "common.atac", "fitness"))

ggplot(data = gp.plotdata, aes(x = gen, y = fraction)) +
  geom_point(alpha = 0.02, position = "jitter", pch = 16) +
  theme_minimal() +
  xlab("Generations") + ylab("Fraction of Hits") +
  facet_wrap(.~method, scale = "free") +
  ggtitle("Genetic Programming: Progressive Sampling Summary - Breast") +
  scale_x_continuous(breaks = seq(0, 150, by = 25))

ggsave(filename = "~/brca_gp_progressive_summary_200kb_50gen_071223_updatedmarkers.png", width = 20, height = 7)


## Top proposal gene and cell distribution
rs11749176 <- top.proposal %>% dplyr::filter(locus == "rs11749176")

celltype <- as.data.frame(table(rs11749176$celltype))
gene <- as.data.frame(table(rs11749176$gene)) %>% 'colnames<-' (c("gene_name", "freq")) %>%
  mutate(snp = "rs11749176") %>%
  left_join(x = ., y = nearbygenes[, c("gene_name", "snp", "side")], by = c("gene_name", "snp"))

ggplot(gene, aes(fill=side, y=freq, x="rs11749176")) + 
  geom_bar(position="stack", stat="identity") +
  theme_minimal() +
  #geom_text(aes(label = freq), size = 3, hjust = 0.5, vjust = 3, position = "stack") +
  xlab("") + ylab("Freq") +
  scale_fill_manual(values = kelly.colours[3:12])

ggplot(celltype, aes(fill=Var1, y=Freq, x="rs11749176")) + 
  geom_bar(position="stack", stat="identity") +
  theme_minimal() +
  #geom_text(aes(label = Freq), size = 3, hjust = 0.5, vjust = 3, position = "stack") +
  xlab("") + ylab("Freq") +
  scale_fill_manual(values = kelly.colours[c(1,13:21)])

load("/drive-pool/data/peter_data/genetic_programming/kelly.colours.rda")
```

Generate summary figures for GA run
```{r}
## Get the maximum hits per OF based on SNP 
obj.fun ## This is the OF used in the GA run

## Function to get maximum hit INDEPENDENT of all other OF; data is nearbygene data
## Before running function. load all data required for GA run above.
get.max.hit <- function(data) {
  data <- data %>% dplyr::select(snp, gene_name)
  if("marker.gene" %in% obj.fun) {
    ## Prepare marker df
    of1 <- combined.gene.marker %>% mutate(hit = 1) %>% dplyr::select(-celltype) %>% distinct()
    d1 <- data %>% left_join(x = ., y = of1, by = c("gene_name"="gene")) %>%
      mutate(hit = replace_na(hit, 0)) %>%
      dplyr::group_by(snp) %>%
      dplyr::summarise(hit = sum(hit)) %>%
      mutate(hit = case_when(hit > 0 ~ 1,
                             hit == 0 ~ 0))
    d1 <- sum(d1$hit)/nrow(d1)
  }
  if("magma" %in% obj.fun) {
    d2 <- data %>% left_join(x = ., y = magma, by = c("gene_name"="gene")) %>%
      mutate(magma = replace_na(magma, 0)) %>%
      dplyr::group_by(snp) %>%
      dplyr::summarise(magma = sum(magma)) %>%
      mutate(magma = case_when(magma > 0 ~ 1,
                               magma == 0 ~ 0))
    d2 <- sum(d2$magma)/nrow(d2)
  }
  if("hi.mut" %in% obj.fun) {
    d3 <- data %>% left_join(x = ., y = breast.cancer.gene, by = c("gene_name"="gene")) %>%
      mutate(cancer.gene = replace_na(cancer.gene, 0)) %>%
      dplyr::group_by(snp) %>%
      dplyr::summarise(cancer.gene = sum(cancer.gene)) %>%
      mutate(cancer.gene = case_when(cancer.gene > 0 ~ 1,
                                     cancer.gene == 0 ~ 0))
    d3 <- sum(d3$cancer.gene)/nrow(d3)
  }
  
}
```



Make heatmap
```{r}
khan.fitness <- test.run[["fitness"]][1,]
top.proposal <- test.run[["top"]] %>% dplyr::filter(n == khan.fitness[,"n"],
                                                    gen == khan.fitness[,"gen"]) %>%
  dplyr::select(-n, -gen)

heatmap.data <- result %>% dplyr::select(locus, gene, celltype)

## Creating heatmap of positive hits by proposal elements
fm <- marker.hits %>% mutate(fm = 1)
cevm <- cevm.genes %>% mutate(cevm = 1)
all.markers <- combined.gene.marker %>% mutate(marker.gene = 1) %>% distinct()

heatmap_of <- function(data) {
  
  #########
  ## PPI ##
  ## Identify all genes that have PPI
  match.set <- ppi %>% left_join(x = ., y = data, by = c("gene1"="gene"),
                                 relationship = "many-to-many") %>%
    dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
    left_join(x = ., y = data, by = c("gene2"="gene"),
              relationship = "many-to-many") %>%
    dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
    na.omit()
  
  ppi.genes <- data.frame(gene = unique(c(match.set$gene1, match.set$gene2)),
                          ppi = 1)
  ################
  ## Marker PPI ##
  ## Identify all genes that have PPI and are expressed in correct celltype
  marker.obj <- match.set %>% left_join(x = ., 
                                        y = all.markers, 
                                        by = c("gene1"="gene", "celltype1"="celltype")) %>%
    left_join(x = ., y = all.markers, by = c("gene2"="gene", "celltype2"="celltype")) %>%
    na.omit()
  ## Get col 1:3
  df1 <- marker.obj[,c(1,3,4)] %>% 'colnames<-' (c("gene", "celltype", "locus"))
  ## Get col 4:6
  df2 <- marker.obj[,c(2,5,6)] %>% 'colnames<-' (c("gene", "celltype", "locus"))
  marker.ppi.gene <- rbind(df1,df2) %>% distinct() %>% mutate(marker.ppi = 1)
  
  #####################
  ## RNA-PROTEIN PPI ##
  ## Get info on proposal
  lnrna.protein.set <- rna.protein.map %>% left_join(x = ., y = data, by = c("gene1"="gene"),
                                             relationship = "many-to-many") %>%
    dplyr::rename("celltype1"="celltype", "locus1"="locus") %>%
    left_join(x = ., y = data, by = c("gene2"="gene"),
              relationship = "many-to-many") %>%
    dplyr::rename("celltype2"="celltype", "locus2"="locus") %>% 
    na.omit()
  if(nrow(lnrna.protein.set) > 1) {
    lncrna.genes <- data.frame(gene = unique(c(lnrna.protein.set$gene1, lnrna.protein.set$gene2)),
                               lncrna = 1)
  } else {
    lncrna.genes <- data.frame(gene = data$gene,
                               lncrna = 0)
  }

  
  #################
  ## ATAC marker ##
  m.atac.set <- data %>% left_join(x = ., y = atac.marker, by = c("locus", "celltype")) %>%
    dplyr::filter(marker.atac == 1)
  
  #################
  ## ATAC common ##
  c.atac.set <- data %>% left_join(x = ., y = common.atac.hit, by = c("locus", "celltype")) %>%
    dplyr::filter(common.atac == 1)
  
  ###########
  ## GO.CC ##
  # go.ppi.df <- match.set %>% dplyr::select(-celltype1, -celltype2) %>%
  #     left_join(x = ., ## Add cellular component info for all genes in gene1 (NA means no info on gene)
  #               y = map.go.gene[,c("external_gene_name", "name_1006")], 
  #               by = c("gene1"="external_gene_name"), 
  #               relationship = "many-to-many") %>%
  #     dplyr::rename("cc1"="name_1006") %>% ## Rename cc column as cc1 to link to gene1
  #     left_join(x = ., ## Add cc info for gene2
  #               y = map.go.gene[,c("external_gene_name", "name_1006")],
  #               by = c("gene2"="external_gene_name"),
  #               relationship = "many-to-many") %>%
  #     dplyr::rename("cc2"="name_1006") %>% ## Rename cc column as cc2 to link to gene2
  #     .[which(.$cc1 == .$cc2),] ## Filter for cases where gene1 and gene2 are in same cellular compartment
  #   ## Get all genes from go.ppi.df
  #   go.genes <- data.frame(gene = unique(c(go.ppi.df$gene1, go.ppi.df$gene2)),
  #                          go.cc = 1)
    
    ###############
    ## Inter.ppi ##
    inter.obj <- marker.obj %>% left_join(x = ., 
                                          y = celltalkdb[,c("source_genesymbol", "inter.ppi")], 
                                          by = c("gene1"="source_genesymbol"),
                                          relationship = "many-to-many") %>%
      distinct() %>%
      dplyr::rename("source_gene1" = "inter.ppi") %>%
      left_join(x = ., 
                y = celltalkdb[,c("source_genesymbol", "inter.ppi")],
                by = c("gene2"="source_genesymbol"),
                relationship = "many-to-many") %>%
      distinct() %>% 
      dplyr::rename("source_gene2" = "inter.ppi") %>%
      .[which(rowSums(.[,c("source_gene1", "source_gene2")], na.rm = TRUE) == 1),] %>%
      
      ## Now trying to find targets the same way we did for source genes
      left_join(x = ., 
                y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                by = c("gene1"="target_genesymbol"),
                relationship = "many-to-many") %>%
      distinct() %>%
      dplyr::rename("target_gene1" = "inter.ppi") %>%
      left_join(x = ., 
                y = celltalkdb[,c("target_genesymbol", "inter.ppi")],
                by = c("gene2"="target_genesymbol"),
                relationship = "many-to-many") %>%
      distinct() %>%
      dplyr::rename("target_gene2" = "inter.ppi") %>%
      .[which(rowSums(.[,c("target_gene1", "target_gene2")], na.rm = TRUE) == 1),] %>%
      ## Removing target and source identity column
      dplyr::select(-source_gene1, -source_gene2, -target_gene1, -target_gene2)
    
    df1 <- inter.obj %>% dplyr::select(gene1, celltype1, locus1) %>% 'colnames<-' (c("gene", "celltype", "locus")) %>% distinct()
    df2 <- inter.obj %>% dplyr::select(gene2, celltype2, locus2) %>% 'colnames<-' (c("gene", "celltype", "locus")) %>% distinct()
    inter.ppi.set <- rbind(df1, df2) %>% mutate(inter.ppi = 1) %>% distinct()
  
  ###############
  ## Intra.ppi ##
  intra.df <- match.set %>% mutate(intra.commun = case_when(celltype1 == celltype2 ~ 1,     
                                                            celltype1 != celltype2 ~ 0)) %>%
      dplyr:::filter(intra.commun == 1) %>%
      group_by(grp = paste(pmax(gene1, gene2), ## Keep only intra combo (no celltalk combo)
                               pmin(gene1, gene2), sep = "_")) %>%
      dplyr::filter(!grp %in% celltalk_gene$grp) %>%
      ungroup() %>%
      dplyr::select(-grp) %>%
      distinct()
    
  df1 <- intra.df %>% dplyr::select(gene1, celltype1, locus1) %>%
    dplyr::rename("gene"="gene1", "celltype"="celltype1", "locus"="locus1")
  df2 <- intra.df %>% dplyr::select(gene2, celltype2, locus2) %>%
    dplyr::rename("gene"="gene2", "celltype"="celltype2", "locus"="locus2")

  intra.ppi.genes <- rbind(df1, df2) %>% distinct() %>%
    mutate(intra.ppi = 1)
  
  #######################
  ## Get final summary ##
  res <- data %>% left_join(x = ., y = fm, by = c("gene", "celltype")) %>%
    left_join(x = ., y = cevm, by = c("gene", "celltype")) %>%
    left_join(x = ., y = ppi.genes, by = "gene") %>%
    left_join(x= ., y = marker.ppi.gene, by = c("gene", "locus", "celltype")) %>%
    left_join(x = ., y = magma, by = c("gene")) %>%
    left_join(x = ., y = breast.cancer.gene, by = c("gene")) %>%
    left_join(x = ., y = promoter.df, by = c("gene", "locus")) %>%
    left_join(x = ., y = lncrna.genes, by = c("gene")) %>%
    left_join(x = ., y = m.atac.set, by = c("gene", "locus", "celltype")) %>%
    left_join(x = ., y = c.atac.set, by = c("gene", "locus", "celltype")) %>%
    #left_join(x = ., y = go.genes, by = "gene") %>%
    left_join(x = ., y = inter.ppi.set, by = c("gene", "locus", "celltype")) %>%
    left_join(x = ., y = intra.ppi.genes, by = c("gene", "locus", "celltype")) %>%
    distinct()
    # mutate(proposal_elem = paste(gene, locus, celltype, sep = "_")) %>%
    # dplyr::select(-gene, -locus, -celltype) %>%
    # distinct() %>%
    # column_to_rownames(var = "proposal_elem")
  
  res[is.na(res)] <- 0
  
  res
}

df <- heatmap_of(data = top.proposal)
df <- heatmap_of(data = heatmap.data)

x <- pheatmap(df[c(4:15)],
              fontsize_row = 7,
              #annotation_row = row_anno
)

## Something for dennis. comparing top result with OF hits summary
result <- result %>% left_join(x = ., y = df, by = c("locus", "gene", "celltype"))
write.table(result, file = "~/summ.confidcall.txt")
## End of sometlhing fro dennis

rdendro.order <- rownames(df)[x$tree_row$order]
cdendro.order <- names(df)[x$tree_col$order]

gg.df <- df %>% rownames_to_column(var = "prop.elem") %>%
  gather(data = ., key = "of", value = "hit", -prop.elem)

gg.df$prop.elem <- factor(x = gg.df$prop.elem, levels = rev(rdendro.order))
gg.df$of <- factor(x = gg.df$of, levels = cdendro.order)

color.hit <- c("grey", "firebrick3")
names(color.hit) <- c("0", "1")
dev.off()
of.plot <- ggplot(gg.df, aes(x = of, y = prop.elem, fill = as.character(hit))) +
  geom_tile() +
  scale_fill_manual(values = color.hit) +
  xlab("") + ylab("") + labs(fill = "Status") +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 8),
    axis.text.y = element_text(size = 6)
  )
of.plot
ggsave(filename = "~/of.plot.png", width = 7, height = 14)


## Taking a look at cases that have no OF hits. There are 33 cases

no.of <- df[rowSums(df[,c(4:15)]) == 0, "locus"]
# rsid.no.of <- data.frame(prop.elem = rownames(no.of)) %>% 
#   separate(prop.elem, sep = "_", c("gene", "locus", "celltype")) %>% 
#   pull(locus)


null.ct.distri <- test.run[["proposal"]] %>% dplyr::filter(locus %in% no.of)
null.ct.distri <- as.data.frame(table(null.ct.distri$celltype, null.ct.distri$locus))
#null.ct.distri$Freq <- null.ct.distri$Freq / n_proposal
load("/drive-pool/data/peter_data/genetic_programming/kelly.colours.rda")

ggplot(null.ct.distri, aes(fill=Var1, y=Freq, x=Var2)) + 
    geom_bar(position="stack", stat="identity") +
  scale_fill_manual(values = kelly.colours[3:22]) +
  xlab("SNP") + ylab("Frequency") + labs(fill = "") +
  ggtitle("Celltype distribution of SNPs with 0 hits in top.proposal") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

## End of chisq test

## Check null nearby genes... do they have any gene that have PPI with another gene from diff loci?
null.ppi <- ppi %>% left_join(x = ., 
                              y = nearbygenes[, c("snp", "gene_name")], 
                              by = c("gene1"="gene_name"),
                              relationship = "many-to-many") %>%
  dplyr::rename("snp1"="snp") %>%
  left_join(x = .,
            y = nearbygenes[, c("snp", "gene_name")],
            by = c("gene2"="gene_name"),
            relationship = "many-to-many") %>%
  dplyr::rename("snp2"="snp") %>%
  distinct() %>%
  mutate(grp = paste(snp1, snp2, sep = "_"))

## Grep grp for rsid with no OF hits
null.ppi <- null.ppi[grep(pattern=paste(rsid.no.of,collapse="|"), x = null.ppi$grp),]
snp.w.hits <- top.proposal$locus[!top.proposal$locus %in% rsid.no.of]
## Grep grp for rsid with OF hits
null.ppi <- null.ppi[grep(pattern=paste(snp.w.hits,collapse="|"), x = null.ppi$grp),]

table(rsid.no.of %in% null.ppi$snp1) ## 28 out of 33 snp with no OF hits have ppi interaction
table(rsid.no.of %in% null.ppi$snp2)

## Identify proposal elements with good information. Compare confidence score estimates to null distribution

## Calculate estimates confidence score for each rank per locus
by_rsid <- null.ct.distri %>% dplyr::group_by(Var2) %>% 
  dplyr::arrange(desc(Freq), .by_group = TRUE) %>%
  mutate(rank = rep(x = c(1:10), times = length(no.of)))

ggplot(data = by_rsid, aes(x = Freq)) +
  geom_density() +
  theme_bw() +
  xlim(c(0,1)) +
  facet_wrap(.~rank) +
  ggtitle("Null Ranked Cell Type Confidence Score")


rank1 <- by_rsid %>% dplyr::filter(rank == 1)
rank1.density <- density(rank1$Freq)
plot(rank1.density)

rank2 <- by_rsid %>% dplyr::filter(rank == 2)
rank2.density <- density(rank2$Freq)
plot(rank2.density)



beta_params(mean = 0.5885, sigma = 0.1642)
plot(density(rbeta(100000,shape1 = 4.69737*2,shape2 =3.284567*2)))
lines(density(rank1$Freq), col = "red")
beta_params(mean = 0.19150, sigma = 0.10729)
plot(density(rbeta(100000,shape1 = 2.384223,shape2 =10.06603)), xlim = c(0,1))
lines(density(rank2$Freq), col = "red")
lines(density(rbeta(1e5, shape1 = 93/10, shape2 = (1e3-93)/10)))
lines(density(rbeta(1e5, shape1 = 93, shape2 = (1e3-93))))

null.den <- rbeta(1e5,shape1 = 2.384223,shape2 =10.06603)
obs.den <- rbeta(1e5, shape1 = 93/10, shape2 = (1e3-93)/10)

### Question 1: what is the fold enrichment
plot(density(obs.den/null.den), main = "fold enrichment")
### Question 2: is the breast cancer gene enriched relative to background?
plot(density(obs.den), xlim = c(0,1))#, xlim = c(0, 0.025), ylim = c(0, 300))
lines(density(null.den), col='grey')
lines(density(obs.den-null.den), col='red')

res <- obs.den - null.den ## Fg - Bg ... to see how many times the Fg is larger than the Bg
CI <- 0.025
quant_diff <- quantile(res, c(CI, 0.5, 1-CI))
quant_diff
pval <- sum(res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
pval


## Enrichment calculation to identify snps 

## Preparing data for enrichement calc
top.res <- test.run[["top"]] ## Get top run from GA
ct.distri <- as.data.frame(table(top.res$celltype, top.res$locus)) ## Table celltype by locus

## Rank cell confidence calls and keep rank 1 and 2
## Keeping rank 1 and 2 b/c they have some explanatory power (pattern) that all null share in distribution of 
## confidence calls
ct.distri <- ct.distri %>% dplyr::group_by(Var2) %>% 
  dplyr::arrange(desc(Freq), .by_group = TRUE) %>%
  mutate(rank = rep(x = c(1:10), times = length(unique(ct.distri$Var2)))) %>%
  dplyr::filter(rank %in% c(1,2)) %>%
  dplyr::select(-Var1) %>%
  dplyr::rename("snp"="Var2")

## write function to perform enrichment calc using beta distribution

## Get null for r1 and r2 using the null distribution
null.r1 <- rbeta(100000,shape1 = 4.69737*2,shape2 =3.284567*2)
null.r2 <- rbeta(1e5,shape1 = 2.384223,shape2 =10.06603)

CI <- 0.025
counter <- 1
## Create empty df to store res
enrich.res <- as.data.frame(matrix(data = NA, nrow = length(loci), ncol = 13))
names(enrich.res) <- c("snp", "r1_pval", "r2_pval", "r1_lower", "r1_med", "r1_upper", "r2_lower", "r2_med", "r2_upper", "r1_lower1", "r1_upper1", "r2_lower1", "r2_upper1")
for(n in loci) {
  message(paste0("Working on snp ", n, " : ", counter))
  ## Subset data based on rank
  spec.loci <- ct.distri %>% dplyr::filter(snp == n)
  ## Store loci in snp col
  enrich.res[counter, "snp"] <- n
  for(p in c(1:2)) { ## p is rank. we are checking rank 1 and rank 2
    ## Get specific rank confidence call
    spec.rank <- spec.loci %>% dplyr::filter(rank == p) %>% pull(Freq)
    ## rbeta for observed
    obs.r <- rbeta(n = 1e5, shape1 = spec.rank, shape2 = n_proposal-spec.rank) 
    ## Instead of using 
    if(p == 1) {
      res <- obs.r/null.r1 ## Calculate fold change
      res.diff <- quantile(res, c(CI, 0.5, 1-CI)) ## Calculate quant
      res.pval <- sum(res >= 1) / 1e5 ## Calculate pvalue
      ## Store result
      enrich.res[counter, "r1_pval"] <- res.pval
      enrich.res[counter, "r1_lower"] <- as.numeric(res.diff[1])
      enrich.res[counter, "r1_med"] <- as.numeric(res.diff[2])
      enrich.res[counter, "r1_upper"] <- as.numeric(res.diff[3])
      enrich.res[counter, "r1_lower1"] <- as.numeric(res.diff[1]) > 1
      enrich.res[counter, "r1_upper1"] <- as.numeric(res.diff[3]) < 1
      
    } else if(p == 2) {
      res <- obs.r/null.r2 ## Calculate fold change
      res.diff <- quantile(res, c(CI, 0.5, 1-CI)) ## Calculate quant
      res.pval <- sum(res >= 1) / 1e5 ## Calculate pvalue
      ## Store result
      enrich.res[counter, "r2_pval"] <- res.pval
      enrich.res[counter, "r2_lower"] <- as.numeric(res.diff[1])
      enrich.res[counter, "r2_med"] <- as.numeric(res.diff[2])
      enrich.res[counter, "r2_upper"] <- as.numeric(res.diff[3])
      enrich.res[counter, "r2_lower1"] <- as.numeric(res.diff[1]) > 1
      enrich.res[counter, "r2_upper1"] <- as.numeric(res.diff[3]) < 1
    }
  }
  counter <- counter + 1
}

rm(counter, pval, obs.r, res, rank.r, rank.col, spec.rank, n, p); gc()

r1.hits <- enrich.res %>% dplyr::filter(r1_lower1 == TRUE,
                                        r1_upper1 == FALSE,
                                        r2_lower1 == FALSE,
                                        r2_upper1 == TRUE)
r1.hits.id <- r1.hits$snp

r2.hits <- enrich.res %>% dplyr::filter(r2_lower1 == FALSE,
                                        r2_upper1 == TRUE)
r2.hits.id <- r2.hits$snp

r1 <- result %>% dplyr::filter(locus %in% r1.hits.id)
r2 <- result %>% dplyr::filter(locus %in% r2.hits.id)

plot(density(null.r2))
lines(density(obs.r), col = "red")
lines(density(res), col = "grey")

plot(density(null), col = "red")
lines(density(null.r2))
plot(density(null.r1), xlim = c(0,1))
lines(density(null.r2), col = "grey")

obs.r <- rbeta(n = 1e5, shape1 = 865, shape2 = 1000-865)
res <- obs.r/null.r1
quantile(res, c(CI, 0.5, 1-CI))
pval <- sum(res >= 1) / 1e5
pval

plot(density(obs.r), col = "red", xlim = c(0,1))
lines(density(null.r1))


n = 1e6
garibaldi_north <- rbeta(n, 16, 2438) # fraction of G relative to L, northside
garibaldi_south <- rbeta(n, 3, 3113) # fraction of G relative to L, southside
south_v_north <- garibaldi_south/garibaldi_north # ratio on south vs north
quantile(south_v_north, probs = c(0.025, 0.975))

plot(density(garibaldi_north), col = "red", xlim = c(-0.015,0.015))
lines(density(garibaldi_south))
lines(density(south_v_north), col = "blue")
p_value <- sum(south_v_north >= 1) / n
print(p_value)


## Get top khan 
top.proposal <- test.run[["top"]]
fitness.proposal <- test.run[["fitness"]][1,]

khan <- top.proposal %>% dplyr::filter(gen == fitness.proposal$gen,
                                       n == fitness.proposal$n)
```








#################################
## Code not used ################
#################################
Download GWAS summary stat data for BRCA from most recent paper
```{r}
## Using table downloaded from gwas summary statistic
## https://www.ebi.ac.uk/gwas//api/search/summaryStatistics/download
gwas_ss <- fread(file = "/drive-pool/data/peter_data/genetic_programming/gwas/list_gwas_summary_statistics.tsv") %>%
  dplyr::rename("traits" = "Trait(s)") ## Rename Trait(s) as traits

phenotype <- data.frame(traits = unique(gwas_ss$traits))
b.phenotype <- phenotype$traits[grep(pattern = "breast", x = phenotype$traits)]
brca <- b.phenotype[c(3,4,5)]; rm(b.phenotype, phenotype)

b_gwas_ss <- gwas_ss %>% dplyr::filter(traits %in% brca); rm(gwas_ss, brca) 
## Chose PMID 34662886 b/c it was one of the most recent papers and had the most samples and variants analyzed.

## Download summary stat from http://ftp.ebi.ac.uk/pub/databases/gwas/summary_statistics/GCST90081001-GCST90082000/GCST90081349
rm(b_gwas_ss); gc()
ss <- read.table(file = "/drive-pool/data/peter_data/genetic_programming/gwas/brca/GCST90079129_buildGRCh38.tsv.gz",
                 header = TRUE) %>% 
  dplyr::filter(p_value <= 0.05)

## Consolidate snps into loci - finding the lead snp
signif.snps <- ss %>% dplyr::select(Name, chromosome, base_pair_location) %>%
  'colnames<-' (c("SNP_id", "seqnames", "start"))

snps.list <- as.list(as.data.frame(t(signif.snps)))

signif.snps$cytoband <- unlist(mclapply(X = snps.list, FUN = function(x) {
  chrom_id <- as.numeric(x[2])
  if(chrom_id == 23) {
    chrom_id <- "X"
  }
  quantsmooth::position2Cytoband(chrom = chrom_id, 
                                 position = as.numeric(x[3]), 
                                 units = "hg38")
},
mc.cores = 10
))

rm(snps.list)
## Append pval to signif snps
signif.snps <- signif.snps %>% left_join(x = ., y = gwas.snps[, c("SNPS", "P-VALUE")], by = c("SNP_id"="SNPS")) %>%
  distinct() %>% rownames_to_column(var = "rowid") %>%
  dplyr::rename("pval"="P-VALUE")
```

