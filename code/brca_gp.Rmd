---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r libraries}
suppressMessages(c(
  library(tidyverse),
  library(data.table),
  library(motifbreakR, include.only = "snps.from.rsid"),
  library(SNPlocs.Hsapiens.dbSNP155.GRCh38),
  library(BSgenome.Hsapiens.UCSC.hg38),
  library(parallel),
  library(quantsmooth),
  library(pheatmap),
  library(GenomicRanges),
  library(sctransform),
  library(Seurat),
  library(HGNChelper),
  library(ArchR),
  library(dampack)
))
```

Get nearby genes for each credible snp
```{r}
## Load RNA-seq data
rna <- readRDS("/drive-pool/data/peter_data/sc_data/brca/GSE168836/GSE168836_Sobj_Final_Scaled_MetaUpdt_V2.rds")
## sctransform
sct_rna <- SCTransform(rna, vst.flavor = "v2", verbose = TRUE,
                       return.only.var.genes = TRUE)
#save(sct_rna, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/sct_rna.rda")
################################
## Find Nearby Genes from SNP ##
## Create df object using processed gtf.v38.mapped.gene

## Load gtf file used in alignment
gtf <- import("/drive-pool/data/peter_data/genetic_programming/shared_data/refdata-gex-GRCh38-2020-A/genes/genes.gtf")

gtf.df <- gtf %>% as.data.frame() %>% 
  dplyr::filter(type == "gene",
                gene_type %in% c("protein_coding", "lncRNA"))

dup.genes <- gtf.df[which(duplicated(gtf.df$gene_name)),]$gene_name

for(n in dup.genes) {
  dup <- gtf.df %>% dplyr::filter(gene_name %in% n) %>% arrange(., gene_version) ## Arrange version by increasing order
  
  dup.rm <- which(gtf.df$gene_name == dup[1,"gene_name"] & ## Which row needs to be removed
        gtf.df$gene_version == dup[1,"gene_version"])
  
  gtf.df <- gtf.df[-dup.rm,] ## Remove it from gtf.df
}; rm(dup, dup.rm); gc()

table(duplicated(gtf.df$gene_name)) ## No more dups

geneAnnot.df <- gtf.df %>% dplyr::select(seqnames,
                                         start,
                                         end,
                                         strand,
                                         gene_name,
                                         gene_type)

geneWidth <- gtf.df %>% dplyr::select(gene_name, gene_type, width)
save(geneWidth, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/geneWidth.rda")

# load("~/gwas/PCa/calc.zscore.all.genes.rda"); rm(calc.avg, calc.tpm, calc.zscore); gc()
# geneAnnot.df <- gtf.v38.mapped.gene %>% dplyr::select(seqnames,
#                                                       start,
#                                                       end,
#                                                       strand,
#                                                       x)
## Get transcription start site based on strand info
geneAnnot.df$tss <- NA
geneAnnot.df[which(geneAnnot.df$strand == "+"), "tss"] <- geneAnnot.df[which(geneAnnot.df$strand == "+"), "start"]
geneAnnot.df[which(geneAnnot.df$strand == "-"), "tss"] <- geneAnnot.df[which(geneAnnot.df$strand == "-"), "end"]
geneAnnot.df$seqnames <- as.character(geneAnnot.df$seqnames)

#save(geneAnnot.df, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")

## Prep data for finding nearest genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda") ## gene annotation
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda") ## Finemap snp
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda") ## Snps in LD with finemap snp

## Simply df to only include relevant column. Also, add column to say what SNPs have LD
snps.df <- gwas_finemap %>% dplyr::select(CHR_ID, CHR_POS, SNP_ID_CURRENT) %>%
  dplyr::rename("seqnames"="CHR_ID", "start"="CHR_POS", "SNP_id"="SNP_ID_CURRENT") %>% ## Rename columns
  mutate(seqnames = paste0("chr", seqnames)) %>% ## add chr before chromosome id
  distinct() %>% ## Keep unique observations
  left_join(x = ., ## What lead SNPs have snps in ld
            y = data.frame(SNP_id = unique(ld$LEAD_SNP),
                           LD = 1),
            by = "SNP_id") %>%
  mutate(LD = replace_na(LD, replace = 0))

## Create df to show range of each lead snp based on all SNPs in LD. We are doing this because
## we are trying to include all snps because we don't know the casual snp. This is just the first 
## pass of trying it.
ldsnps.range <- ld %>% dplyr::group_by(LEAD_SNP) %>%
  dplyr::summarise(min = min(CHR_POS),
                   max = max(CHR_POS))

gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type)

gwas.list <- as.list(as.data.frame(t(snps.df[, c("seqnames", "start", "SNP_id", "LD")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- FALSE ## Elmer style is just what the package elmer does. Picks X ngenes left and right of chr position of interest

min.genes <- 10 ## Set the min ngenes a lead snp should have. only needed when elmer.style is false

nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  ## Need to add code for after
  if(x[4] == "0") { ## If there is no SNP in LD. Use the CHR_POS
    ## No SNP, get all genes within distance threshold left and right of snp (400kb window)
    ## If less than 10 genes, keep expanding until you get 10 genes total (5 left and 5 right)
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else { ## If elmer style is FALSE do this
        
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
      mutate(distance_tss = tss - as.numeric(x[2])) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= -distance_thres) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  } ## End of no SNP in LD function
  
  if(x[4] == "1") { ## If there is SNP in LD. Use the MIN and MAX CHR_POS based on all snps
    ## Get the min and max CHR_POS from the set of SNPS in LD.
    ## Expand coords by distance_thres
    ## Use new range to gather nearby genes
    spec.snp.range <- ldsnps.range %>% dplyr::filter(LEAD_SNP == x[3]) %>% dplyr::select(min, max) %>%
      as.numeric()
    ## Expand coords by distance thres. Subtract left and add right
    spec.snp.range[1] <- spec.snp.range[1] - 2e5
    spec.snp.range[2] <- spec.snp.range[2] + 2e5
    ## Find midpoint from that range now.
    mid.point.range <- round(mean(spec.snp.range), digit = 0) ## Find midpoint and round to the nearest whole number
    
    ## Work on right side of SNP (downstream)
    Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., distance_tss)
    if(elmer.style == TRUE) {
      if(nrow(Rside) > 4) {
        Rside <- Rside[1:5,]
        }
      } else {
        ## distance thres is abs(mid-spec.snp.range[1/2])
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Rgenes <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Rgenes) > 4) { ## If there are more than 5 genes...
            Rside <- Rgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Rside <- Rside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Rside <- Rside %>% dplyr::filter(distance_tss <= (spec.snp.range[2] - mid.point.range))
        }
      }
    
    if(nrow(Rside) == 0) {
      ## Do nothing
      } else {
        Rside <- Rside %>% mutate(snp = x[3],
                                  side = paste0("R", c(1:nrow(.))))
      }
    
    ## Work on left side of SNP (upstream)
    Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(mid.point.range)) %>%
      mutate(distance_tss = tss - as.numeric(mid.point.range)) %>%
      arrange(., desc(distance_tss))
    if(elmer.style == TRUE) {
      if(nrow(Lside) > 4) {
        Lside <- Lside[1:5,]
        }
      } else {
        if(!is.null(min.genes)) { ## If there is a min.gene... do this
          Lgenes <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range)) ## Check how many genes after dist.thres filtering
          if(nrow(Lgenes) > 4) { ## If there are more than 5 genes...
            Lside <- Lgenes ## Don't change anything
          } else { ## If less than 5, gather genes based on min.genes
            Lside <- Lside[1:(min.genes/2),]
            }
        } else { ## if min.gene is null (no elmer style)
          Lside <- Lside %>% dplyr::filter(distance_tss >= (spec.snp.range[1] - mid.point.range))
        }
      }
    
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  } ## End of SNP in LD function
  
  ###############################
  ## Combine R and L side gene ##
  ###############################
  if(nrow(Rside) > 0 & nrow(Lside) > 0) { ## Store both
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) { ## If no Rside, only store Lside
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) { ## If no Lside, only store Rside
    res <- Rside
  }
  
},
mc.cores = 20
)

nearbygenes_10xgenomics <- as.data.frame(do.call(rbind, nearbygenes))
## Sometimes there are no more genes at the tail end of the chromosome. Those will come back as NA. Remove NAs
nearbygenes_10xgenomics <- na.omit(nearbygenes_10xgenomics)
save(nearbygenes_10xgenomics, file = "/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")

as.data.frame(table(nearbygenes_10xgenomics$snp)) %>%
  ggplot(data = ., aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Total ngenes") + ylab("Density") +
  ggtitle(paste0("Number of Genes per SNP - ", length(unique(nearbygenes_10xgenomics$snp)), " SNPs"))

df <- as.data.frame(table(nearbygenes_10xgenomics$snp))


```

Generate findmarker data for breast data
```{r}
load("/drive-pool/data/peter_data/genetic_programming/code/brca/sct_rna.rda") ## Load sctransform data
#sct_rna@active.ident <- sct_rna@meta.data$CellType
#sct_rna$ID_coarse <- as.character(sct_rna@meta.data$CellType)
sct_rna$SampleType = ifelse(grepl("CF", sct_rna@meta.data$orig.ident), "CF", "TM")
Idents(sct_rna) <- sct_rna@meta.data[["CellType"]]
sct_rna <- subset(x = sct_rna, subset = SampleType == "CF") ## Filter data for only CF data

celltype <- unique(as.character(sct_rna@meta.data[["CellType"]]))

marker.list <- list()

for(n in celltype) {
  for(p in celltype) {
    if(n == p) { ## If comparison is same cell type, next
      next
    } else { ## If not the same cell type, find markers
    message(paste0("Working on celltype ", n, " vs ", p))
    vs.group <- paste(n,"vs",p, sep = "_")
      marker <- FindMarkers(sct_rna, assay = "SCT", ident.1 = n, ident.2 = p, test.use = "wilcox",
                        only.pos = TRUE)
      marker <- marker %>% rownames_to_column(var = "gene") %>%
        mutate(celltype1 = n,
               celltype2 = p)
  marker.list[[vs.group]] <- marker
    }
  }
}

marker.list <- as.data.frame(do.call(rbind, marker.list))
save(marker.list, sct_rna, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda"); rm(sct_rna)
table(marker.list$p_val_adj < 0.05)
ggplot(data = marker.list, aes(x = p_val_adj)) +
  geom_density() +
  theme_minimal() +
  xlab("Adjusted P-Value") + ylab("Density") +
  ggtitle("Distribution of Adj. P-Value for FindMarkers")
#ggsave("/drive-pool/data/peter_data/genetic_programming/figure/distrib_pval_findmarkers.png", width = 10, height = 7)
## Based on the plot above, we need to filter the adj pvalue for significance (<= 0.05)
marker.filtered <- marker.list %>% remove_rownames() %>% dplyr::filter(p_val_adj <= 0.05) %>% 
  dplyr::filter(avg_log2FC >= 0.25)

marker.heatmap <- marker.filtered %>% dplyr::select(gene, celltype1, celltype2) %>%
  mutate(hit = 1) %>%
  spread(data = ., key = celltype2, value = hit)
## Lets see how similar are the marker genes for each cell type
celltype <- unique(marker.filtered$celltype1)

ct.jaccard <- data.frame(matrix(data = NA, nrow = length(celltype), ncol = length(celltype))) %>%
  'colnames<-' (celltype) %>%
  'rownames<-' (celltype)

for(n in celltype) {
  ## Get cell type marker genes
    a <- marker.filtered %>% dplyr::filter(celltype1 == n) %>% 
    pull(gene) %>% unique()
  for(p in celltype) {
    b <- marker.filtered %>% dplyr::filter(celltype1 == p) %>% 
    pull(gene) %>% unique()
    ct.jaccard[n,p] <- jaccard(a = a, b = b)
  }
}

pheatmap(ct.jaccard)

marker.hits <- marker.filtered %>% dplyr::select(gene, celltype1) %>% 
  dplyr::rename("celltype"="celltype1") %>%
  distinct() 

## Calculate the n celltype for each marker
marker.plot <- as.data.frame(table(marker.hits$gene))

ggplot(data = marker.plot, aes(x = Freq)) +
  geom_density() +
  theme_minimal() +
  xlab("Number of Celltypes") + ylab("Density") +
  ggtitle("Distribution of Number of Cell Type for Each Marker Gene - FindMarkers") +
  scale_x_continuous(breaks = seq(0, 12, by = 1))

#save(marker.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda")

###########################################################################################
## This is extra code to try to find marker relative to all other celltypes (background) ##
marker.list <- list()

for(n in celltype) {
  message(paste0("Working on celltype ", n))
  marker <- FindMarkers(sct_rna, assay = "SCT", ident.1 = n, ident.2 = NULL, test.use = "wilcox",
                        only.pos = TRUE)
  marker <- marker %>% rownames_to_column(var = "gene") %>%
    mutate(celltype = n)
  marker.list[[n]] <- marker
}

marker.list <- as.data.frame(do.call(rbind, marker.list))
save(marker.list, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda")

marker.filtered <- marker.list %>% remove_rownames() %>% 
  dplyr::filter(p_val_adj <= 0.05,
                avg_log2FC >= 0.25)

marker.hits <- marker.filtered %>% dplyr::select(gene, celltype) %>%
  distinct() 

save(marker.list, marker.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda")

```

Promoter data
```{r}
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")
## Get atac-seq probes and make into granges
genes.granges <- GRanges(seqnames = Rle(nearbygenes$seqnames),
                       range = IRanges(start = nearbygenes$tss),
                       gene = nearbygenes$gene_name)
genes.granges <- unique(genes.granges)

promoter.granges <- promoters(genes.granges, upstream = 1000, downstream = 100)
## Make gwas snps into granges

all.snps <- gwas_finemap[,c("CHR_ID", "CHR_POS", "SNP_ID_CURRENT")] %>%
  dplyr::rename("SNPS"="SNP_ID_CURRENT") %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))
## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = promoter.granges)

promoter.df <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(promoter.granges) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  mutate(promoter = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
promoter.df[which(is.na(promoter.df$LEAD_SNP)), "LEAD_SNP"] <- promoter.df[which(is.na(promoter.df$LEAD_SNP)), "locus"] 

save(promoter.df, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ld_promoter.df.rda")
```

Fusion Gene Objective Function
```{r}
rm(list = ls(all.names = T)); gc()

fusion.gene <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cosmic_fusion.txt")

## Process the data to split genepair column into two separate genes
fusion.gene <- fusion.gene %>% dplyr::select(genepair) %>%
  separate(genepair, sep = " / ", c("protein1", "protein2")) %>%
  mutate(protein1 = gsub(pattern = "_.*", replacement = "", x = protein1),
         protein2 = gsub(pattern = "_.*", replacement = "", x = protein2)) %>% 
  distinct()

fusion.gene <- data.frame(gene = unique(c(fusion.gene$protein1, fusion.gene$protein2)),
                          fusion = 1)

load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_elmer_10xgenomic.rda")
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)

table(fusion.gene$gene %in% unique(nearbygenes$gene_name)) ## Only 5 match. Maybe it's not found in the nearbygenes. Maybe it's in the full gtf file.

## Checking that
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")

table(fusion.gene$gene %in% geneAnnot.df$gene_name) ## Yep. 74 out of 75 is present. So it seems like we only have 5 matches for the fusion gene.

save(fusion.gene, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
```

SNP in coding region
```{r}
rm(list = ls(all.names = T)); gc()

## Load gtf file
gtf <- import("/drive-pool/data/peter_data/genetic_programming/shared_data/refdata-gex-GRCh38-2020-A/genes/genes.gtf")

gtf.df <- gtf %>% as.data.frame() %>% 
  dplyr::filter(type %in% c("exon"),
                gene_type %in% c("protein_coding", "lncRNA")); rm(gtf)

## Load snp file
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/snpinLD.rda")

## Convert both snp and gtf to granges object

all.snps <- gwas_finemap[,c("CHR_ID", "CHR_POS", "SNP_ID_CURRENT")] %>%
  dplyr::rename("SNPS"="SNP_ID_CURRENT") %>%
  rbind(.,
        ld[,c("CHR_ID", "CHR_POS", "SNPS")]) %>%
  distinct()

gwas <- GRanges(seqnames = Rle(paste0("chr", all.snps$CHR_ID)),
                range = IRanges(start = as.numeric(all.snps$CHR_POS) - 500,
                                end = as.numeric(all.snps$CHR_POS) + 499),
                locus = all.snps$SNPS,
                chr_pos = as.numeric(all.snps$CHR_POS))

gtf <- GRanges(seqnames = Rle(gtf.df$seqnames),
                       range = IRanges(start = gtf.df$start,
                                       end = gtf.df$end),
                       strand = Rle(gtf.df$strand),
                       gene = gtf.df$gene_name,
               exon = gtf.df$exon_number)

## Find overlaps between snp and promoter region
hits <- findOverlaps(query = gwas, subject = gtf)

coding.hits <- cbind(as.data.frame(gwas) %>% .[hits@from,],
                       as.data.frame(gtf) %>% .[hits@to,]) %>%
  remove_rownames() %>%
  dplyr::select(locus, gene) %>%
  distinct() %>%
  mutate(coding = 1) %>%
  left_join(x = ., 
            y = distinct(ld[,c("SNPS", "LEAD_SNP")]), 
            by = c("locus"="SNPS"))

## Anything that is NA in LEAD_SNP is column the locus is the lead snp
coding.hits[which(is.na(coding.hits$LEAD_SNP)), "LEAD_SNP"] <- coding.hits[which(is.na(coding.hits$LEAD_SNP)), "locus"] 
save(coding.hits, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ld.coding.hits.rda") ## 23 hits in coding (ld now has 234 gene hit)

```

Highly Mutated/Cancer Gene Objective Function
```{r}
cosmic_cancer_consus <- fread(file = "/drive-pool/data/peter_data/genetic_programming/shared_data/Census_allThu Aug 10 16 27 49 2023.tsv") %>%
  .[grep(pattern = "breast", x = .$"Tumour Types(Somatic)")] %>% ## Select genes associated with breast cancer
  dplyr::rename("gene"="Gene Symbol") %>% ## Rename spec. col for easy selection
  dplyr::select(gene) %>% distinct() %>% ## Select spec column 
  mutate(source = "cosmic")

# PMID 27161491: 173 most frequently mutated gene (2,433 primary tumours and 650 normal non-cancerous samples)
pmid_27161491 <- readxl::read_xlsx("/drive-pool/data/peter_data/genetic_programming/shared_data/41467_2016_BFncomms11479_MOESM809_ESM.xlsx",
                       skip = 2) %>% 
  dplyr::rename("gene"="HGNC_symbol") %>%
  dplyr::select(gene) %>% distinct() %>%
  mutate(source = "27161491")

pmid_31287869 <- readxl::read_xlsx("/drive-pool/data/peter_data/genetic_programming/shared_data/ExcelSupp_gkz566.xlsx") %>%
  dplyr::rename("gene"="Gene") %>% 
  dplyr::filter(BRCA != "-") %>%
  dplyr::select(gene) %>%
  mutate(source = "31287869")

breast.cancer.gene <- data.frame(gene = unique(c(cosmic_cancer_consus$gene, pmid_27161491$gene, pmid_31287869$gene)),
                                 cancer.gene = 1)

#save(breast.cancer.gene, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")

## Dennis has concerns that the number of hits in the fg is a little high. Checked to see if fg is over/under-representated using beta distribuion

rm(list = ls(all.names = T)); gc()
library(tidyverse)
library(data.table)
library(BSgenome.Hsapiens.UCSC.hg38)
library(parallel)

load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")

## Load in hg38 genome
hg38 <- GRanges(seqinfo(BSgenome.Hsapiens.UCSC.hg38))
hg38 <- keepStandardChromosomes(hg38, pruning.mode = "coarse")
hg38 <- dropSeqlevels(hg38, "chrM", pruning.mode = "coarse")

## Randomly sample from hg38
chrid <- paste0("chr", gwas_finemap$CHR_ID)

## Randomly sample genomic region using chr id from gwas_finemap (fg)
sample.granges <-unlist(mclapply(X = chrid, FUN = function(x){
  ## Get ranges from granges for specific chr id
  chr.data <- hg38[seqnames(hg38) %in% x] %>% ranges()
  ## Sample from chr.range
  pos <- sample(x = start(chr.data):end(chr.data), size = 1)
},
mc.cores = 10
))

## Create df of chrid and random pos
bg.granges <- data.frame(seqnames = chrid,
                         start = sample.granges) %>%
  mutate(SNP_id = paste(seqnames,start,sep="_")) %>%
  distinct()

## Get nearby genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/geneAnnot.df.rda")
gene.tss <- geneAnnot.df %>% dplyr::select(seqnames, tss, gene_name, gene_type) ## Keep relevant col

## Turn df that needs nearby genes to list
gwas.list <- as.list(as.data.frame(t(bg.granges[, c("seqnames", "start", "SNP_id")])))

distance_thres <- 2e5 ## Distance threshold is 200kb from snp left and right

elmer.style <- TRUE

## Get nearby genes function
bg_nearbygenes <- mclapply(X = gwas.list, FUN = function(x) {
  
  gA.filter <- gene.tss %>% dplyr::filter(seqnames == x[1])
  
  Rside <- gA.filter %>% dplyr::filter(tss >= as.numeric(x[2])) %>%
    mutate(distance_tss = tss - as.numeric(x[2])) %>%
    arrange(., distance_tss)
  if(elmer.style == TRUE) {
    if(nrow(Rside) > 4) {
      Rside <- Rside[1:5,]
    }
  } else {
    Rside <- Rside %>% dplyr::filter(distance_tss <= distance_thres)
  }
  if(nrow(Rside) == 0) {
    ## Do nothing
  } else {
    Rside <- Rside %>% mutate(snp = x[3],
                              side = paste0("R", c(1:nrow(.))))
  }
  
  
  Lside <- gA.filter %>% dplyr::filter(tss < as.numeric(x[2])) %>%
    mutate(distance_tss = tss - as.numeric(x[2])) %>%
    arrange(., desc(distance_tss))
  if(elmer.style == TRUE) {
    if(nrow(Lside) > 4) {
      Lside <- Lside[1:5,]
    }
  } else {
    Lside <- Lside %>% dplyr::filter(distance_tss >= -distance_thres)
  }
  if(nrow(Lside) == 0) {
    ## Do nothing
  } else {
    Lside <- Lside %>% arrange(., distance_tss) %>%
      mutate(snp = x[3],
             side = paste0("L", rev(c(1:nrow(.)))))
  }
  
  if(nrow(Rside) > 0 & nrow(Lside) > 0) {
    res <- rbind(Lside, Rside)
  } else if (nrow(Rside) == 0 & nrow(Lside) > 0) {
    res <- Lside
  } else if ((nrow(Rside) > 0 & nrow(Lside) == 0)) {
    res <- Rside
  }
  
},
mc.cores = 20
)
## List to df
bg_nearbygenes <- as.data.frame(do.call(rbind, bg_nearbygenes))
## Checking the distribution of ngenes for each bg snp. (Checking sides e.g. L1, L2, L3)
#table(bg_nearbygenes$side)

## Clean up
rm(nearbygenes, chrid, distance_thres, elmer.style, sample.granges, geneAnnot.df, 
   gene.tss, hg38, bg.granges, gwas.list, gwas_catalog, gwas_finemap); gc()

## Load in fg nearbygenes
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_elmer_10xgenomic.rda")
fg_nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics); gc() ## Rename fg obj

## beta distribution test. Is the number of breast cancer genes that we observe between the fg and bg equal or diff?
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")

bg_gene <- unique(bg_nearbygenes$gene_name)
bg_hits <- length(bg_gene[bg_gene %in% breast.cancer.gene$gene])

fg_gene <- unique(fg_nearbygenes$gene_name)
fg_hits <- length(fg_gene[fg_gene %in% breast.cancer.gene$gene])

bg_rbeta <- rbeta(n = 1e5, shape1 = bg_hits, shape2 = length(bg_gene)-bg_hits)
fg_rbeta <- rbeta(n = 1e5, shape1 = fg_hits, shape2 = length(fg_gene)-fg_hits)

### Question 1: what is the fold enrichment
plot(density(fg_rbeta/bg_rbeta), main = "fold enrichment")
### Question 2: is the breast cancer gene enriched relative to background?
plot(density(fg_rbeta))#, xlim = c(0, 0.025), ylim = c(0, 300))
lines(density(bg_rbeta), col='grey')
lines(density(fg_rbeta-bg_rbeta), col='red')

res <- fg_rbeta - bg_rbeta ## Fg - Bg ... to see how many times the Fg is larger than the Bg
CI <- 0.025
quant_diff <- quantile(res, c(CI, 0.5, 1-CI))
quant_diff
pval <- sum(res < 0)/1e5 ## How many times is the fg less than the bg? divided by n in rbeta
pval

```

Compartment of Genes Objective Function
```{r}
library(GO.db)
xx <- as.list(GOTERM)

x <- sapply(xx, Ontology) ## There are 43,249 GO terms
x <- names(x)[which(x == "CC")] ## 4043 cellular compartment terms

x2 <- xx[names(xx) %in% x]

cc.goterms <- sapply(x2, Term)
cc.goterms <- data.frame(goid = names(cc.goterms),
                         goterm = tolower(cc.goterms)) %>%
  remove_rownames()

ec.cc <- c("cytoplasm", "cytoskeleton", "endoplasmic reticulum", "endosome", "extracellular region",
           "golgi apparatus", "intracellular vesicle", "lysosome", "mitochondrion", "nucleus",
           "peroxisome", "plasma membrane", "ribosome"
           )

selected.cc.go <- cc.goterms %>% dplyr::filter(goterm %in% ec.cc)

## Get the children of selected cc
cc.child <- as.list(GOCCCHILDREN) %>% .[names(.) %in% selected.cc.go$goid]
test1 <- as.list(GOCCOFFSPRING) %>% .[names(.) %in% selected.cc.go$goid]


## Using biomart to extract genes associated with selected GO ID
library(biomaRt)
# listEnsemblArchives() ## Checking available ensembls
# Ensembl 110 Jul 2023 https://jul2023.archive.ensembl.org     110
ensembl <- useEnsembl(biomart = "ensembl", 
                      dataset = "hsapiens_gene_ensembl",
                      host = "https://jul2023.archive.ensembl.org")

## for loop to get all genes associated with selected GO ID
map.go.gene <- list()
for(n in 1:nrow(selected.cc.go)) {
  message(paste0("Working on ", selected.cc.go$goid[n], " : ", selected.cc.go$goterm[n]))
  df <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "go_id", "name_1006"), # "namespace_1003"
              filters = "go", 
              values = selected.cc.go$goid[n], 
              mart = ensembl)
  df <- df %>% dplyr::filter(go_id %in% selected.cc.go$goid[n]) %>% distinct()
  map.go.gene[[selected.cc.go$goterm[n]]] <- df
}
map.go.gene <- as.data.frame(do.call(rbind, map.go.gene))
map.go.gene <- remove_rownames(map.go.gene)

save(map.go.gene, file = "/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
```

CelltalkDB - Ligand receptor ppi from PMID 33147626
```{r}
## Download cvs from review paper https://github.com/LewisLabUCSD/Ligand-Receptor-Pairs PMID 33168968
celltalkdb <- fread("~/Human-2022-Dimitrov-LR-pairs.csv")

# table(unique(nearbygenes$gene_name) %in% unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))
## 74 out of 1844 genes found in celltalkdb. I don't expect a lot of matches b/c this is cell-cell interaction
## But in any case, I'll double check to see if there are any updated gene names in celltalkdb.

check.gene <- checkGeneSymbols(x = unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))
table(check.gene$Approved) ## Only 182 not approved. Checking those. 
false.gene <- check.gene %>% dplyr::filter(Approved == FALSE) ## Falses are due to protein complex
## Are these subunit in the celltalkdb as a separate thing?
"ERBB2" %in% unique(celltalkdb$target_genesymbol) ## It's there. Lets check something else with grep
celltalkdb[grep(pattern = "ERBB2", x = celltalkdb$target_genesymbol),]
## Okay so ERBB2_ERBB4 is a complex and it has a source. So we need to separate the target so we can account for that. 

## Separate complex in source and target column
celltalkdb <- celltalkdb %>% separate_rows(target_genesymbol, sep = "_") %>% 
  separate_rows(source_genesymbol, sep = "_") %>% 
  dplyr::select(source_genesymbol, target_genesymbol) %>%
  distinct()
#table(unique(nearbygenes$gene_name) %in% unique(c(celltalkdb$source_genesymbol, celltalkdb$target_genesymbol)))

## Getting rid of duplicates (reverse pairs)
celltalkdb <- celltalkdb %>% group_by(grp = paste(pmax(target_genesymbol, source_genesymbol), pmin(target_genesymbol, source_genesymbol), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  select(-grp) %>%
  distinct()
  
celltalkdb$inter.ppi <- 1
save(celltalkdb, file = "/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
```

Protein-protein interaction
```{r}
## Load in PPI data from stringdb version 11.5
str.db.link <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/9606.protein.links.full.v11.5.txt.gz") %>%
  as.data.frame() %>%
  dplyr::filter(experiments != 0 | experiments_transferred != 0)

str.db.info <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/9606.protein.info.v11.5.txt.gz") %>%
  as.data.frame() %>%
  .[,1:2] %>% 'colnames<-' (c("string_id", "gene_symbol")) %>%
  distinct()

if(length(unique(str.db.info$string_id)) == nrow(str.db.info)) {
  message("Good, unique string id")
} else {
  message("Beware, there are some duplicated string id")
}

## There are 3 duplicated genes though. It's okay though.
str.db.info$gene_symbol[which(duplicated(str.db.info$gene_symbol))]

## check to see if there are any outdated gene name?
check.gene <- checkGeneSymbols(x = str.db.info$gene_symbol) 
## Taking a look at false genes
false.gene <- check.gene %>% dplyr::filter(Approved == FALSE)

## There are false genes without suggested symbol. Lets see if anything of them stand out. Looking manually
na.gene <- false.gene %>% dplyr::filter(is.na(Suggested.Symbol))

## Manual fixes. The rest are novel genes with ENSG/LOC id
check.gene[which(check.gene$x == "HGNC:9982"), "Suggested.Symbol"] <- "RFX1"
check.gene[which(check.gene$x == "HGNC:9979"), "Suggested.Symbol"] <- "RFPL2"

## Apply fixes to genes with suggested symbol
suggested.gene <- false.gene %>% dplyr::filter(!is.na(Suggested.Symbol))
## There are some with multiple suggested.symbol. If you grep with "///"
## Using manually curated txt file to fix those
suggested.fix <- vroom::vroom(file = "/drive-pool/data/peter_data/gwas_path/multigene.suggested.fix.txt")

for(n in suggested.fix$x) {
  check.gene[which(check.gene$x == n), "Suggested.Symbol"] <- suggested.fix[which(suggested.fix$x == n), "Fixed.Suggested"]
}
## Sanity check. good all multiple cases are fixed
check.gene[grep(pattern = "///", x = check.gene$Suggested.Symbol),] 

## Removing the cases with the multiple gene suggestion "///" so we can apply the other fixes 
suggested.gene <- suggested.gene[-grep(pattern = "///", x = suggested.gene$Suggested.Symbol),]
## Apply fix to updated gene name
for(n in suggested.gene$x) {
  check.gene[which(check.gene$x == n), "Suggested.Symbol"] <- suggested.gene[which(suggested.gene$x == n), "Suggested.Symbol"]
}

## Finally, genes without any updates are just updated on Suggested.Symbol
check.gene[which(is.na(check.gene$Suggested.Symbol)), "Suggested.Symbol"] <- check.gene[which(is.na(check.gene$Suggested.Symbol)), "x"]

str.db.info <- str.db.info %>% left_join(x = ., y = check.gene[,c("x", "Suggested.Symbol")], by = c("gene_symbol"="x")) %>%
  distinct()

rm(false.gene, na.gene, suggested.gene, suggested.fix); gc()

## Load nearbygene info
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda")
nearbygenes <- nearbygenes_10xgenomics %>%
  dplyr::select(snp, gene_name, gene_type) %>%
  left_join(x = ., y = str.db.info, by = c("gene_name"="Suggested.Symbol"))
rm(nearbygenes_10xgenomics)

map.genes <- nearbygenes

## Checking the number of unmap genes by gene_type
table(is.na(nearbygenes$string_id), nearbygenes$gene_type) 
## Thats the best we can do for now.

#save(str.db.info, str.db.link, map.genes, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
```




Genetic Programming
```{r}
rm(list = ls(all.names = T)); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_sct_marker.list_pairwise.rda")
load("/drive-pool/data/peter_data/genetic_programming/breast_nearbygenes_200kb_notelmer_10xgenomic_with_LD.rda") ## candidates near snps
nearbygenes <- nearbygenes_10xgenomics; rm(nearbygenes_10xgenomics)
load("/drive-pool/data/peter_data/genetic_programming/code/brca/gwas_finemap.rda")  ## gwas catalog and finemap
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_marker.list.rda") ## marker genes
load("/drive-pool/data/peter_data/genetic_programming/code/brca/marker.list.bg.rda"); rm(marker.list); gc()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ld_promoter.df.rda")
promoter.df <- promoter.df %>% mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_cevm.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ld_atac.marker.rda")
atac.marker <- atac.marker %>% dplyr::rename("marker.atac"="atac") %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast.cancer.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/fusion.gene.rda")
## Merge fusion.gene with breast.cancer.gene
fusion.gene <- fusion.gene %>% dplyr::rename("cancer.gene"="fusion") ## Rename colname for rbind
breast.cancer.gene <- rbind(breast.cancer.gene, fusion.gene) ## rbind together
breast.cancer.gene <- distinct(breast.cancer.gene); rm(fusion.gene) ## Keep unique observation
#load("/drive-pool/data/peter_data/genetic_programming/shared_data/map.go.gene.cellular.component.rda")
load("/drive-pool/data/peter_data/genetic_programming/shared_data/celltalkdb.rda")
celltalkdb$inter.ppi <- 1 ## Add 
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ld_common_atac_peak.rda")
common.atac.hit <- common.atac.hit %>% dplyr::select(locus, GroupReplicate, LEAD_SNP) %>%
  dplyr::rename("celltype"="GroupReplicate") %>%
  mutate(common.atac = 1) %>%
  distinct() %>%
  mutate(locus = LEAD_SNP) %>%
  dplyr::select(-LEAD_SNP) %>%
  distinct()


loci2gene <- nearbygenes %>% dplyr::select(snp, gene_name) %>% 
  remove_rownames() %>%
  dplyr::rename("cytoband"="snp") %>%
  distinct()

loci <- unique(loci2gene$cytoband) 

###########################################
## Gene Ontology Cellular Component Prep ##
#go_gene <- map.go.gene %>% dplyr::filter(external_gene_name %in% loci2gene$gene_name)
## There is 1844 unique genes in loci2gene, but only 741 mapped with map.go.gene. Why? Naming issue? Lets check
# check.gene <- checkGeneSymbols(unique(map.go.gene$external_gene_name)) %>%
#   dplyr::filter(x != "")
# updated.gene <- check.gene %>% dplyr::filter(Approved == FALSE)
## It's just not mapped to it. Tried updating the gene symbol but no additional matches
#table(go_gene$external_gene_name %in% unique(geneAnnot.df$gene_name))
## Check the original gtf file and all genes from go_gene is present.
## Just the snp doesn't hit those genes. Moving forward.

#############################################
## Highly Mutated/Cancer Driver Genes Prep ##
# breast.cancer.gene

# table(breast.cancer.gene$gene %in% unique(loci2gene$gene_name)) ## Only 20 genes map to loci2gene why?
## Checking to see if gene has updated symbol
# check.gene <- checkGeneSymbols(unique(breast.cancer.gene$gene))
# table(check.gene$Approved == FALSE) ## 185 have the most uptodate gene symbol...
## Lets check loci2gene
# check.gene <- checkGeneSymbols(unique(loci2gene$gene_name)) %>% dplyr::filter(Approved == FALSE) 
## Nope. Most genes with FALSE for approved are noncoding rna. and the very few with updates, they aren't found in breast.cancer.gene.
## So it's really only 20 genes for highly mutated genes/ cancer genes based on these snps
## Check the original gtf file and 186 of 190 genes from breast cancer gene is present.
## Again, just the snp doesn't hit those genes. Moving forward.

############
## PPI df ##
load("/drive-pool/data/peter_data/genetic_programming/code/brca/ppi.map.rda")
## Update the link data to have gene symbol
str.db.link <- str.db.link %>% dplyr::select(protein1, protein2, experiments, 
                                             experiments_transferred, combined_score) %>%
  left_join(x = ., y = str.db.info, by = c("protein1"="string_id")) %>%
  dplyr::rename("gene1"="gene_symbol") %>%
  left_join(x = ., y = str.db.info, by = c("protein2"="string_id")) %>%
  dplyr::rename("gene2"="gene_symbol") %>%
  .[,c("protein1", "protein2", "gene1", "gene2", "experiments", "experiments_transferred", "combined_score")]

ppi <- str.db.link %>% dplyr::select(gene1, gene2) %>%
  dplyr::filter(gene1 %in% map.genes$gene_name, 
                gene2 %in% map.genes$gene_name) %>% ## Filter for specific genes found in gwas 200kb
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct(); rm(str.db.info, map.genes, str.db.link); gc()


## Prepare intra.cellular ppi
## Remove gene combo found in celltalkdb
celltalk_gene <- celltalkdb %>% dplyr::select(source_genesymbol, target_genesymbol) %>%
  dplyr::rename("gene1"="source_genesymbol", "gene2"="target_genesymbol") %>%
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_"))
  
intra.ppi.gene <- ppi %>% 
  group_by(grp = paste(pmax(gene1, gene2), 
                       pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(!grp %in% celltalk_gene$grp) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct()

######################
## Load Magma genes ##
magma <- fread("/drive-pool/data/peter_data/genetic_programming/code/brca/UKB_Breast_cancer.gene_score.txt") %>%
  'colnames<-' ("n") %>%
  separate(n, sep = ":", c("gene", "Mscore")) %>% 
  mutate(magma = 1) %>% dplyr::select(-Mscore)

#table(magma$gene %in% unique(nearbygenes$gene_name)) ## 173 magma genes found out of 1k based on 206 snps
#table(magma$gene %in% unique(geneAnnot.df$gene_name)) ## 952 magma genes found out of 1k in original gtf.
## Again, just the snp doesn't hit those genes. Moving forward.

## Combine findmarkers and cevm
combined.gene.marker <- rbind(cevm.genes, marker.hits) %>% distinct()

## Load lncRNA interaction
load("/drive-pool/data/peter_data/genetic_programming/code/brca/rna.protein.map.rda")
rna.protein.map <- rna.protein.map %>% 'colnames<-' (c("gene1", "gene2")) %>%
  group_by(grp = paste(pmax(gene1, gene2), pmin(gene1, gene2), sep = "_")) %>%
  dplyr::filter(row_number() == 1) %>%
  ungroup() %>%
  dplyr::select(-grp) %>%
  distinct()

## Load motifbreakR in SNP and expressed in proposed cell type
load("/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/tfbs.gene.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_ct_exp.rda"); rm(ct_tpm); gc()

ct_exp <- ct_exp %>% dplyr::filter(expressed == TRUE) %>% 
  dplyr::select(gene_name, type) %>%
  distinct() %>%
  remove_rownames() %>%
  dplyr::filter(gene_name %in% unique(mb.tfbs.disrupt$geneSymbol))

mb.tfbs.disrupt$tfbs <- 1

 # save(atac.marker, breast.cancer.gene, celltalkdb, celltalk_gene, cevm.genes, common.atac.hit, cevm.genes, combined.gene.marker,
 #      common.atac.hit, intra.ppi.gene, magma, marker.hits, ppi, promoter.df, rna.protein.map, 
 #      file = "/drive-pool/data/peter_data/repo/genetic_algorithm_gwas_sc/brca.gp.prereq.rda")
## Generate 1k proposals
celltype <- as.character(unique(sct_rna$CellType))
n_proposal <- 1e3
multi_proposal <- mclapply(X = as.list(1:n_proposal), FUN = function(x) {
  generate_proposal() %>% mutate(n = x)
  },
  mc.cores = 10)

multi_proposal <- as.data.frame(do.call(rbind, multi_proposal))
#save(multi_proposal, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi_proposal_012924.rda")
## Objective function
obj.fun <- c("marker.gene", "magma", "hi.mut", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter","marker.atac", "common.atac", "tfbs") #, "cevm", , "multi.ppi", "findmarkers", "cevm", "go.cc.ppi" #, 

obj.fun <- c("ppi", "inter.ppi", "intra.ppi", "lncrna.ppi", "promoter")

## Run GP model

## Test run to make sure everything is good
ga.run <- gwas_gp(init.proposal = multi_proposal, generations = 5, obj.fun = obj.fun, khan.method = TRUE)

## GP parallel run
date()
multi.gp <- mclapply(X = as.list(1:3), FUN = function(x) {
  gwas_gp(init.proposal = multi_proposal, generations = 100, obj.fun = obj.fun, khan.method = TRUE)
  }, mc.cores = 3)
date()
save(multi.gp, file = "/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_021624.rda")

###################
## Post analysis ##
###################
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/test.run_markerfix.rda")
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/ga.run_breast.rda")
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run.rda")
#load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_nofusion.rda")
# load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_110723.rda")
# load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_nobreastmultiomics_013124.rda")
# load("/drive-pool/data/peter_data/genetic_programming/code/brca/multi.run_021624.rda")
# load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_multi.run_nobreastmultiomics_022024.rda")
load("/drive-pool/data/peter_data/genetic_programming/code/brca/breast_multi.run_022624.rda")

test.run <- multi.gp[[3]]
#test.run <- ga.run
top.proposal <- test.run[["proposal"]]
loci <- 206
genes <- subset(top.proposal, select = c(locus, gene))
geneframe <- data.frame(locus=character(length(loci)), gene = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(genes$locus)) {
  genetab <- as.data.frame(table(subset(genes, locus==i)))
  topgene <- which(genetab$Freq == max(genetab$Freq))
  if(length(topgene)>1) {
    topgene <- which(genetab$Freq == max(genetab$Freq)) %>% .[1]
  }
  geneframe[j,1] <- as.character(genetab[topgene,1])
  geneframe[j,2] <- as.character(genetab[topgene,2])
  geneframe[j,3] <- genetab[topgene,3]
  j <- j+1
}

cells <- subset(top.proposal, select = c(locus, celltype))
cellframe <- data.frame(locus=character(length(loci)), celltype = character(length(loci)), Freq = integer(length(loci)))
j <- 1
for (i in unique(cells$locus)) {
  celltab <- as.data.frame(table(subset(cells, locus == i)))
  topcell <- which(celltab$Freq == max(celltab$Freq))
  if(length(topcell)>1) {
    topcell <- which(celltab$Freq == max(celltab$Freq)) %>% .[1]
  }
  cellframe[j,1] <- as.character(celltab[topcell,1])
  cellframe[j,2] <- as.character(celltab[topcell,2])
  cellframe[j,3] <- celltab[topcell,3]
  j <- j+1
}

result <- merge(geneframe, cellframe, by = "locus") %>%
  left_join(x = ., y = distinct(nearbygenes[, c("gene_name", "gene_type")]), by = c("gene"="gene_name"))
#result %>% dplyr::filter(Freq.x >= 700, Freq.y >= 700) %>% .[order(desc(.$Freq.x), desc(.$Freq.y)),]
#write.table(x = result, file = "~/summ.confidcall.txt", quote = FALSE, row.names = FALSE)

fitness.allgen <- as.data.frame(do.call(rbind, test.run[1:100]))

gp.plotdata <- fitness.allgen %>% gather(data = ., key = "method", value = "fraction", -n, -gen)
unique(gp.plotdata$method)
gp.plotdata$method <- factor(gp.plotdata$method, levels = c("marker.gene", "magma", "cancer.gene", "ppi", "marker.ppi", "inter.ppi", "intra.ppi", "lncrna", "promoter", "marker.atac", "common.atac","fitness")) 

ggplot(data = gp.plotdata, aes(x = gen, y = fraction)) +
  geom_point(alpha = 0.02, position = "jitter", pch = 16) +
  theme_minimal() +
  xlab("Generations") + ylab("Fraction of Hits") +
  facet_wrap(.~method, scale = "free") +
  ggtitle("Genetic Programming: Lexicase Sampling Summary - Breast") +
  scale_x_continuous(breaks = seq(0, 100, by = 25))

ggsave(filename = "~/brca_gp_progressive_summary_200kb_50gen_071223_updatedmarkers.png", width = 20, height = 7)

result %>% dplyr::filter(Freq.x >= 700,
                         Freq.y >= 700)

## Elite comparison with last gen
elite <- test.run[["top"]] %>%
  dplyr::filter(n == 101,
                gen == 69) %>%
  dplyr::rename("celltype_elite"="celltype", "gene_elite"="gene") %>% 
  dplyr::select(locus, gene_elite, celltype_elite)

compare_top <- result %>% dplyr::filter(Freq.x >= 700,
                                        Freq.y >= 700) %>%
  dplyr::arrange(., desc(Freq.x), desc(Freq.y)) %>%
  left_join(x = ., y = elite, by = "locus")

## Calculate elite fitness score
exclude.celltype <- NULL
elite$n <- 1
elite <- elite %>% dplyr::rename(., "celltype"="celltype_elite", "gene"="gene_elite")
elite_fitness <- calc_fitness(df = elite, obj.fun = obj.fun)
## Calculate consensus fitness score
consensus_fitness <- result %>% dplyr::select(locus, gene, celltype) %>%
  mutate(n = 1) %>%
  calc_fitness(df = ., obj.fun = obj.fun)

## Density plot of last gen fitness
last.gen.fitness <- test.run[[150]]
last.gen.fitness <- last.gen.fitness %>% dplyr::select(fitness) %>% rownames_to_column("proposal")
ggplot(data = last.gen.fitness, aes(x = fitness)) +
  geom_density(fill = "grey50", alpha = 0.5) +
  theme_bw() +
  geom_vline(aes(xintercept = elite_fitness),
            color = "blue", linetype = "dashed", size = 0.5) +
  geom_vline(aes(xintercept = consensus_fitness),
            color = "red", linetype = "dashed", size = 0.5) +
  ggtitle("Density==last.gen.fitness; Blue==elite; Red==consensus")
  

################
## Get OF hit ##
################
consensus_of <- result %>% dplyr::select(locus, gene, celltype) %>%
  mutate(n = "consensus")

plotdata_consensus <- consensus_of %>% dplyr::select(-n) %>% get.of.hits(data = ., obj.fun = obj.fun) %>%
  dplyr::select(-gene, -celltype) %>%
  column_to_rownames(var = "locus")

xx <- pheatmap(mat = plotdata_consensus)

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}
save_pheatmap_pdf(xx, "test.pdf")

proposals <- test.run[["proposal"]] %>% dplyr::select(-gen) %>%
  rbind(., consensus_of)

of.hit.list <- list()
for(p in unique(proposals$n)) {
  print(p)
  df <- proposals %>% dplyr::filter(n == p) %>% 
    dplyr::select(-n) %>%
    get.of.hits(data = ., obj.fun = obj.fun) %>% 
    mutate(of.hit = rowSums(.[4:11])) %>%
    dplyr::select(locus, of.hit) %>%
    mutate(of.hit = case_when(of.hit > 0 ~ 1,
                              of.hit == 0 ~ 0),
           proposal = paste0("proposal_", p))
  of.hit.list[[p]] <- df
  
}

plotdata <- as.data.frame(do.call(rbind, of.hit.list))
plotdata <- plotdata %>% spread(data = ., key = "proposal", value = "of.hit") %>%
  column_to_rownames(var = "locus") 

library(pheatmap)

annotation <- data.frame(Var1 = c(rep(x = "proposal", times = 1e3), "consensus"))
rownames(annotation) <- colnames(plotdata)

pheatmap(mat = plotdata,
         show_rownames = FALSE, 
         show_colnames = FALSE,
         treeheight_col = 0,
         annotation = annotation)

total.locus <- data.frame(n_loci = colSums(plotdata))
consensus.locus <- total.locus[1001,]

individual.proposal <- total.locus %>% rownames_to_column(var = "proposal") %>%
  .[1:1000,] 

ggplot(data = individual.proposal, aes(x = n_loci)) +
  geom_density(fill = "grey", alpha = 0.5) +
  geom_vline(aes(xintercept = consensus.locus),
            color = "red", linetype = "dashed", size = 0.5) +
  theme_bw() +
  ggtitle("Number of Loci with at least one obj func hit")

consensus_of <- result %>% dplyr::select(locus, gene, celltype) %>%
  get.of.hits(data = ., obj.fun = obj.fun) %>% 
  mutate(of.hit = rowSums(.[4:11])) %>%
  dplyr::select(locus, of.hit) %>%
  mutate(of.hit = case_when(of.hit > 0 ~ 1,
                            of.hit == 0 ~ 0))


## Top proposal gene and cell distribution
rs11749176 <- top.proposal %>% dplyr::filter(locus == "rs11749176")

celltype <- as.data.frame(table(rs11749176$celltype))
gene <- as.data.frame(table(rs11749176$gene)) %>% 'colnames<-' (c("gene_name", "freq")) %>%
  mutate(snp = "rs11749176") %>%
  left_join(x = ., y = nearbygenes[, c("gene_name", "snp", "side")], by = c("gene_name", "snp"))

ggplot(gene, aes(fill=side, y=freq, x="rs11749176")) + 
  geom_bar(position="stack", stat="identity") +
  theme_minimal() +
  #geom_text(aes(label = freq), size = 3, hjust = 0.5, vjust = 3, position = "stack") +
  xlab("") + ylab("Freq") +
  scale_fill_manual(values = kelly.colours[3:12])

ggplot(celltype, aes(fill=Var1, y=Freq, x="rs11749176")) + 
  geom_bar(position="stack", stat="identity") +
  theme_minimal() +
  #geom_text(aes(label = Freq), size = 3, hjust = 0.5, vjust = 3, position = "stack") +
  xlab("") + ylab("Freq") +
  scale_fill_manual(values = kelly.colours[c(1,13:21)])

load("/drive-pool/data/peter_data/genetic_programming/kelly.colours.rda")
```






